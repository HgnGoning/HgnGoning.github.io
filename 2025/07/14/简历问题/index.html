<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>简历 | TTDB's blog</title><meta name="author" content="TTDB"><meta name="copyright" content="TTDB"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一版自我介绍我是XXX，本科毕业于XX大学，目前就读于XX大学，目前是是XX。主攻Java技术栈，专注后端开发方向，熟悉Spring Boot、MySQL、Redis等主流技术。 在项目方面，我主要有两个代表性实践：  慧通课程教育平台，采用Spring Cloud微服务架构，使用Mysql,mabaitsplus,redis，minio等中间件的使用 智能医疗大模型，主要是使用当下热门的lan">
<meta property="og:type" content="article">
<meta property="og:title" content="简历">
<meta property="og:url" content="http://example.com/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="TTDB&#39;s blog">
<meta property="og:description" content="第一版自我介绍我是XXX，本科毕业于XX大学，目前就读于XX大学，目前是是XX。主攻Java技术栈，专注后端开发方向，熟悉Spring Boot、MySQL、Redis等主流技术。 在项目方面，我主要有两个代表性实践：  慧通课程教育平台，采用Spring Cloud微服务架构，使用Mysql,mabaitsplus,redis，minio等中间件的使用 智能医疗大模型，主要是使用当下热门的lan">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg">
<meta property="article:published_time" content="2025-07-14T01:26:13.427Z">
<meta property="article:modified_time" content="2025-08-28T02:29:34.322Z">
<meta property="article:author" content="TTDB">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "简历",
  "url": "http://example.com/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/",
  "image": "http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg",
  "datePublished": "2025-07-14T01:26:13.427Z",
  "dateModified": "2025-08-28T02:29:34.322Z",
  "author": [
    {
      "@type": "Person",
      "name": "TTDB",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '简历',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/e93f858d798bea4fbdee83331ff488c.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">TTDB's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">简历</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">简历</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-14T01:26:13.427Z" title="发表于 2025-07-14 09:26:13">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T02:29:34.322Z" title="更新于 2025-08-28 10:29:34">2025-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">java后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我是XXX，本科毕业于XX大学，目前就读于XX大学，目前是是XX。主攻Java技术栈，<strong>专注后端开发方向</strong>，熟悉Spring Boot、MySQL、Redis等主流技术。</p>
<p>在项目方面，我主要有两个代表性实践：</p>
<ol>
<li><strong>慧通课程教育平台</strong>，采用Spring Cloud微服务架构，使用Mysql,mabaitsplus,redis，minio等中间件的使用</li>
<li>智能医疗大模型，主要是使用当下热门的langchain4j框架，开发，实现ai问答以及本地知识库问答</li>
</ol>
<p>平常也会有将自己的技术学习发布自己博客的习惯。</p>
<p>很开兴能有这次面试机会。</p>
<h2 id="Redis-相关问题"><a href="#Redis-相关问题" class="headerlink" title="Redis 相关问题"></a><strong>Redis 相关问题</strong></h2><h3 id="Redis-是用来做什么的？"><a href="#Redis-是用来做什么的？" class="headerlink" title="Redis 是用来做什么的？"></a><strong>Redis 是用来做什么的？</strong></h3><p>redis主要用作高性能的缓存中间件</p>
<ul>
<li><strong>减轻数据库压力：</strong> 将频繁访问但改动不频繁的数据（如课程信息）存储在内存中，用户查询时直接读取 Redis，避免每次请求都访问较慢的 MySQL 数据库。</li>
<li><strong>加速访问速度：</strong> 内存读写速度远快于磁盘（数据库），极大提升了数据获取速度，优化用户体验。</li>
<li><strong>实现特定功能：</strong> 比如用于限流防刷的计数器（<code>INCR</code>）、实现分布式锁（<code>SETNX</code>）、存储限流令牌桶状态等。</li>
</ul>
<h3 id="缓存穿透是怎么解决的？"><a href="#缓存穿透是怎么解决的？" class="headerlink" title="缓存穿透是怎么解决的？"></a><strong>缓存穿透是怎么解决的？</strong></h3><ul>
<li><strong>问题：</strong> 请求查询数据库中<strong>根本不存在</strong>的数据（比如无效的课程ID）。导致请求每次都绕过缓存直接访问数据库，给数据库造成巨大压力。</li>
<li><strong>解决方案（简历中提到的解决思路）：</strong><ul>
<li><strong>缓存空对象：</strong> 当数据库查询不到数据时，在 Redis 中为这个无效 Key 设置一个<strong>短过期时间</strong>的空值（如 <code>&quot;&quot;</code> 或 <code>null</code>）。后续同样的无效请求会命中这个空值缓存，不再访问数据库。</li>
<li><strong>布隆过滤器：</strong> 在查询缓存和数据库<strong>之前</strong>，先用布隆过滤器判断 Key 是否<strong>可能</strong>存在。如果布隆过滤器说“不存在”，则直接返回空结果，避免访问数据库；如果布隆过滤器说“可能存在”，才继续查询缓存&#x2F;数据库。这能有效拦截大量无效请求。</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩：当大量缓存数据在同一时间过期（失效）或者Redis故障宕机时，如果此时有大量的用户请求，都无法在Rdis中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</p>
<h3 id="缓存击穿是怎么解决的？"><a href="#缓存击穿是怎么解决的？" class="headerlink" title="缓存击穿是怎么解决的？"></a><strong>缓存击穿是怎么解决的？</strong></h3><ul>
<li><strong>问题：</strong> 某个<strong>热点数据Key过期瞬间</strong>，同时有<strong>大量并发请求</strong>涌入。这些请求发现缓存失效，全部去访问数据库，导致数据库瞬时压力过大甚至崩溃。</li>
<li><strong>解决方案（简历中提到的解决思路）：</strong><ul>
<li><strong>互斥锁：</strong> 当第一个请求发现缓存失效时，它尝试获取一个<strong>分布式锁</strong>（例如使用 Redis 的 <code>SET key value NX PX expiretime</code> 命令）。只有获取锁成功的请求才能去数据库加载数据并重建缓存。其他并发请求等待锁释放后，直接从重建好的缓存中读取数据，避免都去访问数据库。</li>
<li><strong>逻辑过期：</strong> 在缓存数据中额外存储一个<strong>逻辑过期时间</strong>（比如 <code>expireAt</code> 字段）。程序访问缓存时，先检查逻辑过期时间。<ul>
<li>如果逻辑上未过期，直接返回数据。</li>
<li>如果逻辑上已过期，则获取分布式锁（类似互斥锁方案），拿到锁的线程负责异步更新缓存（设置新的逻辑过期时间），其他线程暂时返回旧的、逻辑上已过期的数据。这避免了请求阻塞，但牺牲了数据的绝对实时性（短暂不一致）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据一致性是怎么实现的？"><a href="#数据一致性是怎么实现的？" class="headerlink" title="数据一致性是怎么实现的？"></a><strong>数据一致性是怎么实现的？</strong></h3><ul>
<li><strong>问题：</strong> 当源数据（MySQL 中的课程信息）发生变更（增删改）时，需要同步更新或失效对应的 Redis 缓存和 Elasticsearch 索引，保证用户看到的是最新数据。</li>
<li><strong>解决方案（简历中提到的本地消息表 + XXL-Job）：</strong><ul>
<li><strong>核心思想：最终一致性。</strong> 不强求缓存&#x2F;索引和数据库在事务完成时立刻一致，但保证在较短时间内达到一致。</li>
<li><strong>流程：</strong><ol>
<li><strong>发起更新：</strong> 业务代码修改 MySQL 数据库中的课程数据。</li>
<li><strong>写入本地消息表：</strong> <strong>在同一个数据库事务中</strong>，向一个专门设计的<strong>本地消息表</strong>插入一条记录。这条记录包含需要更新的数据标识（如课程ID）、操作类型（更新&#x2F;删除）、以及需要同步到哪些中间件（Redis, ES）等信息。<strong>关键点：这步保证了数据库操作和消息记录写入的原子性。</strong></li>
<li><strong>异步任务扫描：</strong> 使用 <strong>XXL-Job</strong> 定时调度一个后台任务。这个任务定期扫描<strong>本地消息表</strong>中状态为“未处理”的消息。</li>
<li><strong>处理消息 &amp; 更新缓存&#x2F;索引：</strong> 任务读取到消息后：<ul>
<li>根据消息内容，执行对应的 Redis 操作（更新或删除缓存）。</li>
<li>根据消息内容，执行对应的 Elasticsearch 操作（更新或删除索引）。</li>
</ul>
</li>
<li><strong>更新消息状态：</strong> 成功处理完 Redis 和 ES 的更新后，将本地消息表中该条消息的状态更新为“已处理”或直接删除。</li>
</ol>
</li>
<li><strong>优点：</strong> 将缓存&#x2F;索引的更新操作异步化，解耦核心业务逻辑，保证核心业务的高性能。通过本地事务保证了消息的可靠存储。</li>
<li><strong>关键点：</strong><ul>
<li>XXL-Job 的任务执行间隔决定了最终一致性的延迟时间（例如每5秒或每10秒扫描一次）。</li>
<li>需要保证处理消息的任务本身是幂等的（即使重复执行也不会产生错误结果），防止网络抖动等原因导致消息重复处理。</li>
<li>需要处理消息处理失败的情况（重试机制、死信队列等）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><p>AOF,RDB</p>
<p>—fork一个子线程完成任务后</p>
<p>定期删除： 定期随机抽取部分键检查并删除过期键</p>
<p>惰性删除：当客户端访问键时，检查是否过期，过期则删除</p>
<p>定时删除：在设置键的过期时间时，创建一个定时器，到期立即删除</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>Redis 提供了 8 种内存淘汰策略，可通过 <code>maxmemory-policy</code>配置项设置：</p>
<h3 id="1-不淘汰策略"><a href="#1-不淘汰策略" class="headerlink" title="1. 不淘汰策略"></a>1. 不淘汰策略</h3><ul>
<li><strong>noeviction</strong>（默认策略）：当内存不足时，新写入操作会报错，读操作正常</li>
</ul>
<h3 id="2-随机淘汰策略"><a href="#2-随机淘汰策略" class="headerlink" title="2. 随机淘汰策略"></a>2. 随机淘汰策略</h3><ul>
<li><strong>allkeys-random</strong>：从所有key中随机淘汰</li>
<li><strong>volatile-random</strong>：从设置了过期时间的key中随机淘汰</li>
</ul>
<h3 id="3-LRU相关策略"><a href="#3-LRU相关策略" class="headerlink" title="3. LRU相关策略"></a>3. LRU相关策略</h3><ul>
<li><strong>allkeys-lru</strong>：从所有key中使用近似LRU算法淘汰</li>
<li><strong>volatile-lru</strong>：从设置了过期时间的key中使用近似LRU算法淘汰</li>
</ul>
<h3 id="4-LFU相关策略"><a href="#4-LFU相关策略" class="headerlink" title="4. LFU相关策略"></a>4. LFU相关策略</h3><ul>
<li><strong>allkeys-lfu</strong>：从所有key中使用近似LFU算法淘汰（Redis 4.0+）</li>
<li><strong>volatile-lfu</strong>：从设置了过期时间的key中使用近似LFU算法淘汰（Redis 4.0+）</li>
</ul>
<h3 id="5-TTL淘汰策略"><a href="#5-TTL淘汰策略" class="headerlink" title="5. TTL淘汰策略"></a>5. TTL淘汰策略</h3><ul>
<li><strong>volatile-ttl</strong>：从设置了过期时间的key中淘汰剩余时间最短的</li>
</ul>
<h2 id="LRU-与-LFU-实现原理"><a href="#LRU-与-LFU-实现原理" class="headerlink" title="LRU 与 LFU 实现原理"></a>LRU 与 LFU 实现原理</h2><h3 id="近似LRU实现"><a href="#近似LRU实现" class="headerlink" title="近似LRU实现"></a>近似LRU实现</h3><p>Redis 使用的是近似LRU算法而非精确LRU，原因是为了节省内存和提高性能：</p>
<ol>
<li>每个对象记录最近一次访问的时间戳</li>
<li>淘汰时随机采样5个(可配置)key，淘汰其中最久未使用的</li>
<li>通过 <code>maxmemory-samples</code>可调整采样数量（默认5）</li>
</ol>
<h3 id="近似LFU实现"><a href="#近似LFU实现" class="headerlink" title="近似LFU实现"></a>近似LFU实现</h3><p>Redis 4.0引入的LFU算法也是近似实现：</p>
<ol>
<li>使用Morris计数器概率算法减少内存占用</li>
<li>每个对象记录：<ul>
<li>24位的时间戳（分钟级精度）</li>
<li>8位的访问频率计数器（对数增长）</li>
</ul>
</li>
<li>计数器会随时间衰减（通过 <code>lfu-decay-time</code>配置）</li>
</ol>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a><strong>Elasticsearch</strong></h2><h3 id="Elasticsearch-是怎么提高检索效率的？"><a href="#Elasticsearch-是怎么提高检索效率的？" class="headerlink" title="Elasticsearch 是怎么提高检索效率的？"></a><strong>Elasticsearch 是怎么提高检索效率的？</strong></h3><ul>
<li><strong>核心机制：倒排索引。</strong><ul>
<li><strong>传统数据库（如 MySQL）：</strong> 按行存储数据。搜索“Java课程”需要扫描每行记录的“课程标题”或“课程描述”字段，效率低下（全表扫描）。</li>
<li><strong>Elasticsearch：</strong> 构建<strong>倒排索引</strong>。<ul>
<li><strong>分词：</strong> 将文本内容（如课程标题、描述）拆分成一个个独立的词条（Term）。例如 “Java 高级编程” 可能被分词为 <code>[&quot;java&quot;, &quot;高级&quot;, &quot;编程&quot;]</code>。</li>
<li><strong>建立映射：</strong> 创建一个巨大的词典，记录每个词条出现在哪些文档（课程）中，以及在文档中的位置、频率等信息。</li>
</ul>
</li>
<li><strong>搜索过程：</strong> 当用户搜索“Java 课程”时：<ol>
<li>对搜索词进行<strong>分词</strong>（得到 <code>[&quot;java&quot;, &quot;课程&quot;]</code>）。</li>
<li>在倒排索引中快速<strong>查找</strong>包含这些词条的文档列表。</li>
<li>根据相关性算法（如 TF-IDF, BM25）<strong>计算</strong>每个文档与搜索词的匹配度。</li>
<li>按匹配度<strong>排序</strong>返回结果。</li>
</ol>
</li>
</ul>
</li>
<li><strong>优势：</strong><ul>
<li><strong>极快的关键字查找：</strong> 直接从词典定位词条，再获取文档列表，复杂度接近 O(1)。</li>
<li><strong>高效全文检索：</strong> 对文本内容分词后建立索引，支持模糊匹配、短语查询、相关性排序等复杂搜索。</li>
<li><strong>分布式架构：</strong> 数据分片（Shard）存储在多台机器上，并行处理查询请求，水平扩展能力强。</li>
</ul>
</li>
<li><strong>在你的项目中：</strong> 为课程信息（标题、描述、标签、分类等）建立 ES 索引后，用户进行课程搜索时，不再需要低效地扫描数据库，而是直接查询 ES 倒排索引，获得毫秒级的响应速度和精准的相关性排序。</li>
</ul>
<h2 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h2><ul>
<li><strong>核心定位：</strong> MinIO 是一个<strong>高性能、分布式、云原生、兼容 Amazon S3 API 的对象存储系统</strong>。</li>
<li><strong>关键特性：</strong><ul>
<li><strong>对象存储：</strong> 与传统的文件系统（如 NTFS、EXT4）或块存储不同，对象存储将数据（文件、图片、视频、文档等）作为 <strong>“对象”</strong> 来管理。每个对象包含：<ul>
<li>数据本身（文件内容）</li>
<li>可扩展的元数据（描述数据的键值对，如文件名、大小、类型、创建时间、自定义标签等）</li>
<li>全局唯一的对象标识符（Object Key）</li>
</ul>
</li>
<li><strong>分布式：</strong> 数据被自动<strong>分片</strong>（Erasure Coding）并<strong>分散</strong>存储在一个集群的多个节点（服务器）上。这带来了：<ul>
<li><strong>高可用性：</strong> 即使部分节点或硬盘故障，数据也不会丢失，系统仍可读写。</li>
<li><strong>高扩展性：</strong> 可以轻松地通过增加节点来扩展存储容量和吞吐量。</li>
<li><strong>负载均衡：</strong> 读写请求可以分布到不同节点处理。</li>
</ul>
</li>
<li><strong>高性能：</strong> 设计上追求极高的读写速度，特别适合存储和访问海量图片、视频、日志、备份等非结构化数据。</li>
<li><strong>兼容 S3 API：</strong> 这是 MinIO 最大的优势之一。它几乎完全实现了 Amazon S3 的 RESTful API。这意味着：<ul>
<li>任何原本设计用来与 AWS S3 交互的应用程序、工具、SDK（如 AWS Java SDK）都可以<strong>几乎无缝地切换到 MinIO</strong>，只需修改连接配置（Endpoint、AccessKey、SecretKey）。</li>
<li>开发者可以利用熟悉的 S3 SDK 和编程模式来操作 MinIO。</li>
</ul>
</li>
<li><strong>开源：</strong> 核心代码开源，可以免费自建部署。</li>
<li><strong>云原生：</strong> 非常适合部署在 Kubernetes 等容器编排平台上。</li>
</ul>
</li>
<li><strong>在你的项目中的作用：</strong> 在微服务教育平台中，MinIO 被用作<strong>分布式文件存储系统</strong>，专门负责存储和管理课程相关的<strong>视频、图片、文档等媒体资源</strong>。它取代了传统的单体应用文件服务器，提供了：<ul>
<li><strong>海量存储空间：</strong> 轻松应对大量媒体文件的存储需求。</li>
<li><strong>高并发访问能力：</strong> 支持众多学生同时观看视频或下载资料。</li>
<li><strong>高可靠性和数据安全：</strong> 分布式架构保证数据不丢失。</li>
<li><strong>易于集成：</strong> 使用标准的 S3 SDK (如 <code>aws-sdk-java</code>) 即可方便地在 Java 后端进行上传、下载、删除等操作。</li>
</ul>
</li>
</ul>
<h3 id="断点续传-Resumable-Upload-是如何实现的？"><a href="#断点续传-Resumable-Upload-是如何实现的？" class="headerlink" title="断点续传 (Resumable Upload) 是如何实现的？"></a>断点续传 (Resumable Upload) 是如何实现的？</h3><p>分块上传机制天然为断点续传提供了基础：</p>
<ol>
<li><strong>记录上传状态：</strong><ul>
<li>客户端（通常是你的 Java 后端服务）<strong>需要持久化记录</strong>以下信息：<ul>
<li>文件的唯一标识（如文件名+用户ID+哈希）。</li>
<li>关联的 MinIO <code>UploadId</code>。</li>
<li>文件总大小、总分块数。</li>
<li><strong>已成功上传的分块列表 (<code>PartNumber</code> 和 <code>ETag</code>)。</strong> (最核心！)</li>
<li>（可选）每个分块的上传状态（成功&#x2F;失败&#x2F;上传中）。</li>
</ul>
</li>
<li>这个状态信息通常存储在<strong>数据库</strong>或<strong>Redis</strong>中。这就是你“基于消息表的状态字段”思路的延伸应用。</li>
</ul>
</li>
<li><strong>中断后恢复上传：</strong><ul>
<li>当用户需要恢复上传时，客户端（前端&#x2F;App）会告诉后端：“我要续传文件X”。</li>
<li>后端根据文件标识，查询之前保存的<strong>上传状态记录</strong>。</li>
<li>后端拿到 <code>UploadId</code> 和 <strong>已成功上传的分块列表 (<code>PartNumber</code> 和 <code>ETag</code>)</strong>。</li>
<li>后端计算哪些分块<strong>还没有上传</strong>（例如，总共有 10 个分块，记录显示 1,2,3,5 成功了，那么 4,6,7,8,9,10 需要上传）。</li>
<li><strong>关键步骤：</strong> 后端调用 MinIO API <strong>列出已上传的分块 (List Parts)</strong>：<ul>
<li>传入 <code>UploadId</code>。</li>
<li>获取 MinIO 服务器端当前为该 <code>UploadId</code> 保存的所有成功上传的分块信息 (<code>PartNumber</code> 和 <code>ETag</code>)。</li>
</ul>
</li>
<li>后端<strong>对比</strong>本地存储的已上传分块列表 和 MinIO 服务器端返回的列表：<ul>
<li>确保本地记录的 <code>ETag</code> 与服务器端一致（防止服务器端分块数据损坏或丢失）。</li>
<li>确认真正缺失的分块。</li>
</ul>
</li>
</ul>
</li>
<li><strong>继续上传缺失分块：</strong><ul>
<li>后端只将<strong>缺失的分块</strong>重新分块（或者直接从上次中断的分块开始继续切割）并上传。</li>
<li>上传这些分块时，<strong>必须使用同一个 <code>UploadId</code> 和正确的 <code>PartNumber</code></strong>。</li>
<li>每成功上传一个缺失的分块，就更新本地记录（添加该分块的 <code>PartNumber</code> 和 <code>ETag</code>）。</li>
</ul>
</li>
<li><strong>最终完成：</strong><ul>
<li>当所有分块（包括之前成功和本次续传成功的）都确认上传后，后端发起 <strong>Complete Multipart Upload</strong> 请求，提供完整的、包含所有 <code>PartNumber</code> 和对应 <code>ETag</code> 的有序列表。</li>
<li>MinIO 组合文件，完成上传。</li>
</ul>
</li>
</ol>
<p>总结</p>
<ol>
<li><strong>依赖分块上传 (Multipart Upload)：</strong> 这是 MinIO&#x2F;S3 原生支持的机制，是基础。</li>
<li><strong>客户端状态管理：</strong> <strong>必须</strong>在客户端（你的应用服务器）可靠地记录：<ul>
<li><code>UploadId</code></li>
<li>每个<strong>已成功上传分块</strong>的 <code>PartNumber</code> 和 <code>ETag</code></li>
</ul>
</li>
<li><strong>恢复时校验：</strong> 恢复上传时，<strong>必须</strong>通过 <code>List Parts</code> API 获取服务器端状态，并与本地记录<strong>对比校验</strong>，确保状态一致后再上传缺失块。</li>
<li><strong>使用同一个 UploadId：</strong> 整个续传过程必须使用初始化时得到的同一个 <code>UploadId</code>。</li>
<li><strong>最终完成：</strong> 所有分块上传后，必须调用 <code>Complete</code> 请求才能得到最终文件。</li>
</ol>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>为分布式系统提供<strong>可靠的消息传递、解耦、异步通信和流量削峰</strong>能力</p>
<table>
<thead>
<tr>
<th align="left"><strong>概念</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Producer 制片人</strong></td>
<td align="left">消息生产者（如你的订单服务），发送消息到 Exchange</td>
</tr>
<tr>
<td align="left"><strong>Exchange 交换</strong></td>
<td align="left">消息路由枢纽，根据规则（Binding Key）将消息分发到 Queue</td>
</tr>
<tr>
<td align="left"><strong>Queue 队列</strong></td>
<td align="left">消息缓存队列，消费者从中获取消息</td>
</tr>
<tr>
<td align="left"><strong>Consumer 消费者</strong></td>
<td align="left">消息消费者（如你的通知服务），从 Queue 消费消息并处理</td>
</tr>
<tr>
<td align="left"><strong>Binding Key 绑定密钥</strong></td>
<td align="left">Exchange 和 Queue 的绑定规则（如 <code>order.notify</code>）</td>
</tr>
<tr>
<td align="left"><strong>Routing Key 路由关键字</strong></td>
<td align="left">Producer 发送消息时指定的键（如 <code>sms.paid</code>），Exchange 用它匹配 Binding Key</td>
</tr>
<tr>
<td align="left"><strong>Dead Letter Exchange 死信交换</strong></td>
<td align="left">处理失败或过期消息的“死信”交换机（延迟队列关键组件）</td>
</tr>
</tbody></table>
<h3 id="你是如何使用RabbitMQ进行流量削峰优化代金券抢购的？"><a href="#你是如何使用RabbitMQ进行流量削峰优化代金券抢购的？" class="headerlink" title="你是如何使用RabbitMQ进行流量削峰优化代金券抢购的？"></a>你是如何使用RabbitMQ进行流量削峰优化代金券抢购的？</h3><ul>
<li>前端接收请求后直接写入RabbitMQ队列，而不是直接处理业务逻辑</li>
<li>独立的消费者服务从队列中获取消息进行处理</li>
<li>通过控制消费者数量来控制处理速率</li>
</ul>
<h3 id="如何基于延迟队列处理未支付订单？"><a href="#如何基于延迟队列处理未支付订单？" class="headerlink" title="如何基于延迟队列处理未支付订单？"></a>如何基于延迟队列处理未支付订单？</h3><ul>
<li>创建订单时发送两条消息：<ul>
<li>立即消费的消息：创建订单记录</li>
<li>延迟消息：30分钟后检查订单状态</li>
</ul>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="type">int</span> corePoolSize,    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="type">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="type">long</span> keepAliveTime,  <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">    TimeUnit unit,       <span class="comment">// 时间单位</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 工作队列</span></span><br><span class="line">    ThreadFactory threadFactory,       <span class="comment">// 线程工厂</span></span><br><span class="line">    RejectedExecutionHandler handler   <span class="comment">// 拒绝策略</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>线程池的工作流程是怎样的？</strong><ul>
<li><ol>
<li>提交任务后，先判断核心线程是否已满</li>
</ol>
</li>
<li><ol>
<li>核心线程满则入队，队列满则创建非核心线程</li>
</ol>
</li>
<li><ol>
<li>线程数达到最大值且队列满，触发拒绝策略</li>
</ol>
</li>
<li><ol>
<li>空闲线程超过keepAliveTime会被回收（核心线程默认不回收）</li>
</ol>
</li>
</ul>
</li>
<li><strong>线程池的拒绝策略有哪些？如何自定义？</strong><ul>
<li>内置策略：<ul>
<li><code>AbortPolicy</code>（默认）：抛出RejectedExecutionException</li>
<li><code>CallerRunsPolicy</code>：由提交任务的线程执行</li>
<li><code>DiscardPolicy</code>：直接丢弃任务</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务</li>
</ul>
</li>
<li>自定义：实现<code>RejectedExecutionHandler</code>接口</li>
</ul>
</li>
</ol>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务的出现主要是为了解决在分布式系统环境下数据一致性的问题。</p>
<p><strong>微服务架构</strong>的普及：单体应用拆分为多个服务，每个服务有自己的数据库</p>
<p><strong>业务复杂度增加</strong>：单一数据库无法满足性能、扩展性需求</p>
<p>在分布式系统中，无法同时满足<strong>一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)</strong>，分布式事务是在这种约束下寻求平衡的解决方案。</p>
<p>分布式事务通过协调多个独立的数据存储，确保在分布式环境下仍能保持ACID(原子性、一致性、隔离性、持久性)特性或某种程度上的最终一致性。</p>
<h2 id="基于本地消息表加-XXL-Job-任务调度实现分布式事务控制"><a href="#基于本地消息表加-XXL-Job-任务调度实现分布式事务控制" class="headerlink" title="基于本地消息表加 XXL-Job 任务调度实现分布式事务控制"></a>基于本地消息表加 XXL-Job 任务调度实现分布式事务控制</h2><p>本地消息表是一种经典的分布式事务解决方案，属于<strong>最终一致性</strong>方案。其核心思想是：</p>
<ul>
<li>在业务数据库（如MySQL）中创建一个专门的消息表</li>
<li>当业务操作发生时，先在本地事务中完成业务数据操作和消息记录</li>
<li>通过异步机制（如定时任务）将消息表中的记录发送给其他服务</li>
<li>其他服务消费消息并完成自己的业务操作</li>
</ul>
<p>XXL-Job是一个开源的分布式任务调度平台，可以用来：</p>
<ul>
<li>定时触发任务执行</li>
<li>分布式并行执行任务</li>
<li>监控任务执行状态</li>
<li>失败重试等</li>
</ul>
<ol>
<li><p>业务服务执行本地事务<br>├─ 更新业务数据<br>└─ 写入消息表（同一事务）</p>
</li>
<li><p>XXL-Job定时任务<br>├─ 扫描消息表中未处理的消息<br>├─ 调用下游服务接口<br>└─ 根据调用结果更新消息状态（成功&#x2F;失败）</p>
</li>
<li><p>失败重试机制<br>├─ 标记失败的消息会被XXL-Job定期重试<br>└─ 达到最大重试次数后人工介入</p>
</li>
</ol>
<h3 id="问题1：什么是分布式事务？"><a href="#问题1：什么是分布式事务？" class="headerlink" title="问题1：什么是分布式事务？"></a>问题1：什么是分布式事务？</h3><p>由多个服务通过网络完成一个事务叫分布式事务。</p>
<p>比如：课程发布操作不仅要在本地数据库插入课程信息，而且还要请求索引服务将课程信息添加到索引库，还要请求MinIO将课程静态化并上传静态页面，这里就存在分布式事务。</p>
<h3 id="问题2：分布式事务控制的方案有哪些？"><a href="#问题2：分布式事务控制的方案有哪些？" class="headerlink" title="问题2：分布式事务控制的方案有哪些？"></a>问题2：分布式事务控制的方案有哪些？</h3><p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p>
<p>实现CP就是要实现强一致性，可以使用Seata框架基于XA、AT模式去实现。</p>
<p>实现AP强调可用性实现最终一致性，可以使用MQ、任务调度的方式、TCC方式去实现。</p>
<p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p>
<h3 id="问题3：如何使用本地消息表加任务调度完成分布式事务控制？"><a href="#问题3：如何使用本地消息表加任务调度完成分布式事务控制？" class="headerlink" title="问题3：如何使用本地消息表加任务调度完成分布式事务控制？"></a>问题3：如何使用本地消息表加任务调度完成分布式事务控制？</h3><p>以发布课程为例进行说明，发布课程需要在内容管理数据库中写课程发布表记录，同时将课程信息同步到redis、ES、MinIO，这里存在分布式事务。</p>
<p>1）点击发布课程使用本地事务向发布表写一个课程信息，同时向消息表写一个消息记录（标记了发布了哪门课程）</p>
<p>2）xxl-job的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询到了待处理的消息。</p>
<p>3）根据消息的内容将课程信息同步到Redis、ES、MinIO</p>
<p>4）任务完成后删除消息表记录。整个分布式事务完成，最终保证了数据的一致性。</p>
<h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="**XXL-Job **"></a>**XXL-Job **</h2><ul>
<li><strong>定位：</strong> 一个开源的<strong>分布式任务调度平台</strong>。</li>
<li><strong>核心功能：</strong><ul>
<li><strong>任务调度：</strong> 可以非常方便地创建定时任务（Cron表达式）、配置任务执行频率。</li>
<li><strong>任务管理：</strong> 提供可视化控制台，管理任务（启动、停止、暂停、触发执行）、查看任务日志、监控任务执行状态和结果。</li>
<li><strong>分布式执行：</strong> 支持将任务调度到集群中的多个执行器节点上运行，实现负载均衡和容错（一个节点挂了，任务可以调度到其他节点）。</li>
<li><strong>故障转移：</strong> 如果任务执行失败，支持自动重试。</li>
<li><strong>路由策略：</strong> 提供多种策略（轮询、故障转移、忙碌转移等）决定任务分配到哪个执行器。</li>
<li><strong>日志追踪：</strong> 记录任务执行的详细日志，方便排查问题。</li>
</ul>
</li>
<li><strong>在你的项目中：</strong><ul>
<li>被用作<strong>可靠的消息处理器</strong>。XXL-Job 定时调度任务去扫描<strong>本地消息表</strong>中记录的数据变更消息。</li>
<li>这个任务负责读取消息，并根据消息内容<strong>执行具体的 Redis 缓存更新&#x2F;失效操作 和 Elasticsearch 索引更新&#x2F;删除操作</strong>。</li>
<li>利用 XXL-Job 的<strong>分布式能力、定时能力、重试机制和可视化管理</strong>，保证了数据同步任务的可靠、稳定、可监控执行，是实现 Redis&#x2F;ES 与 MySQL 数据最终一致性的关键组件。</li>
</ul>
</li>
</ul>
<h3 id="问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？"><a href="#问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？" class="headerlink" title="问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？"></a>问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？</h3><p>XXL-JOB分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器下发任务，执行器负责接收任务执行任务。</p>
<p>1）首先部署并启动xxl-job调度中心。(一个java工程)</p>
<p>2）首先在微服务添加xxl-job依赖，在微服务中配置执行器</p>
<p>3）启动微服务，执行器向调度中心上报自己。</p>
<p>4）在微服务中写一个任务方法并用xxl-job的注解去标记执行任务的名称。</p>
<ol start="5">
<li>在调度中心添加一个任务并配置调度策略，调度策略就是每隔多长时间执行还是在每天或每月的固定时间去执行，比如每天0点执行，或每隔1小时执行一次等。</li>
</ol>
<p>6）在调度中心启动任务。</p>
<p>7）调度中心根据任务调度策略，到达时间就开始下发任务给执行器。</p>
<p>8）执行器收到任务就开始执行任务。</p>
<h3 id="问题2：如何保证任务不重复执行"><a href="#问题2：如何保证任务不重复执行" class="headerlink" title="问题2：如何保证任务不重复执行?"></a>问题2：如何保证任务不重复执行?</h3><ol>
<li>调度中心按分片广播的方式去下发任务。</li>
</ol>
<p>2）执行器收到作业分片广播的参数：分片总数和分片序号，计算 任务id 除以 执行器总数得到一个余数，如果余数等于执行器序号这时就去执行这个任务，这里保证了不同的执行器执行不同的任务。</p>
<p>3）配置调度过期策略为“忽略”，避免同一个执行器多次重复执行同一个任务</p>
<p>4）配置任务阻塞处理策略为“丢弃后续调度”，丢弃后在下一次调度还可以执行。</p>
<p>5）另外还要保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成，下次再调度执行该任务判断该任务已完成就不再执行。</p>
<p>6）通过分布式锁彻底避免任务多次处理，我们项目使用数据库的乐观锁实现分布式锁，在执行任务前去更新任务的状态为执行中，谁更新成功谁去执行任务。</p>
<p>7）为了避免程序挂掉任务永远是执行器，这里使用任务补偿机制，启动一个定时任务检测在规定的时间内任务还没有完成将任务状态更新 为处理失败。</p>
<h3 id="问题3：任务幂等性如何保证？"><a href="#问题3：任务幂等性如何保证？" class="headerlink" title="问题3：任务幂等性如何保证？"></a>问题3：任务幂等性如何保证？</h3><p>幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。</p>
<p>解决幂等性常用的方案：</p>
<p>1）数据库约束，比如：唯一索引，主键。同一个主键不可能两次都插入成功。</p>
<p>2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。</p>
<p>3）唯一序列号，请求前生成唯一的序列号，携带序列号去请求，执行时在redis记录该序列号表示以该序列号的请求执行过了，如果相同的序列号再次来执行说明是重复执行。</p>
<p>我们项目中在处理任务时为了避免任务重复处理通过任务状态以及数据库乐观锁去保证任务幂等性。</p>
<p>执行过的任务可以打一个状态标记已完成，下次再调度执行该任务判断该任务已完成就不再执行。</p>
<p>在执行任务前使用数据库的乐观锁去更新任务的状态为执行中，谁更新成功谁去执行任务。</p>
<h3 id="问题4：你们项目如何使用xxl-job进行任务调度"><a href="#问题4：你们项目如何使用xxl-job进行任务调度" class="headerlink" title="问题4：你们项目如何使用xxl-job进行任务调度?"></a>问题4：你们项目如何使用xxl-job进行任务调度?</h3><p>我们项目中在控制分布式事务时要保证最终数据一致性，是基于消息表的机制进行控制，这时就使用xxl-job去扫描消息表的记录，根据消息表内容去执行任务，最终保证了数据一致性。</p>
<p>具体xxl-job的使用方法参考上边问题1。</p>
<h3 id="问题5-任务处理达到最大失败次数怎么办？"><a href="#问题5-任务处理达到最大失败次数怎么办？" class="headerlink" title="问题5: 任务处理达到最大失败次数怎么办？"></a>问题5: 任务处理达到最大失败次数怎么办？</h3><p>当任务达到最大失败次数时一般就说明程序处理此视频存在问题，这种情况就需要人工处理，在页面上会提示失败的信息，人工可手动执行该视频进行处理，或通过其它转码工具进行视频转码，转码后直接上传mp4视频。</p>
<h3 id="问题6-如果任务一直没有完成怎么办？"><a href="#问题6-如果任务一直没有完成怎么办？" class="headerlink" title="问题6: 如果任务一直没有完成怎么办？"></a>问题6: 如果任务一直没有完成怎么办？</h3><p>如果有线程抢占了某个视频的处理任务，如果线程处理过程中挂掉了，该任务的状态将会一直是处理中，其它线程将无法处理，这个问题需要用补偿机制。</p>
<p>单独启动一个任务找到待处理任务表中超过执行期限但仍在处理中的任务，将任务的状态改为执行失败。</p>
<p>任务执行期限是处理一个处理的最大时长，比如视频处理任务的最大时长是30分钟，此时就查询大于30分钟还没有完成的任务，将任务状态改为执行失败。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><p>概念类</p>
<ol>
<li>什么是分布式锁？为什么需要分布式锁？<br>答案：<br>分布式锁是在分布式系统中用来协调多个节点对共享资源进行互斥访问的机制。就像单机系统中的锁一样，但作用范围扩展到多台机器。</li>
</ol>
<p>为什么需要：</p>
<p><strong>当多个服务实例同时操作共享资源（如数据库某条记录）时，需要保证同一时间只有一个实例能操作</strong><br>防止重复操作（如重复支付）<br>保证数据一致性（如库存扣减）</p>
<ol start="2">
<li>分布式锁需要满足哪些基本特性？</li>
</ol>
<p>互斥性：同一时刻只有一个客户端能持有锁<br>可重入性：同一个客户端可以多次获取同一把锁<br>锁超时：防止死锁，持有锁的客户端崩溃后能自动释放<br>高可用：锁服务本身要足够可靠<br>非阻塞：获取锁失败时应该有相应处理机制</p>
<h3 id="二、实现方案类"><a href="#二、实现方案类" class="headerlink" title="二、实现方案类"></a>二、实现方案类</h3><ol>
<li>基于数据库的实现方案<br>答案：<br>原理：<br>利用数据库的唯一约束或乐观锁实现。比如创建一张锁表，通过insert一条记录来获取锁，删除记录释放锁。</li>
</ol>
<p>具体实现：</p>
<p>创建锁表：lock(id, resource_name, node_info, expire_time)<br>获取锁：INSERT INTO lock VALUES(…)，成功则获取锁<br>释放锁：DELETE FROM lock WHERE resource_name&#x3D;xxx AND node_info&#x3D;xxx<br>超时处理：定时任务清理过期锁<br>优缺点：</p>
<p>优点：实现简单，依赖少<br>缺点：性能差，数据库压力大，非高可用<br>2. 基于Redis的实现方案<br>答案：<br>原理：<br>利用Redis的SETNX命令（SET if Not eXists）实现原子性操作。</p>
<p>常见实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁</span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line">// 释放锁</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>关键点：</p>
<p>必须设置过期时间（PX参数）<br>value要唯一（如UUID），防止误删其他客户端的锁<br>释放锁时要验证value，确保只能释放自己持有的锁<br>RedLock算法：<br>Redis官方推荐的分布式锁算法，在多个独立的Redis节点上获取锁，当大多数节点获取成功才算真正获取锁。</p>
<ol start="3">
<li>基于Zookeeper的实现方案<br>答案：<br>原理：<br>利用Zookeeper的临时顺序节点和Watcher机制实现。</li>
</ol>
<p>实现步骤：</p>
<ol>
<li><p>在指定路径下创建临时顺序节点</p>
</li>
<li><p>检查自己是否是最小序号节点，是则获取锁</p>
</li>
<li><p>不是则监听前一个节点的删除事件</p>
</li>
<li><p>前一个节点释放锁（节点被删除）后，重新检查</p>
</li>
<li><p>完成业务后删除自己的节点释放锁</p>
</li>
</ol>
<p>优势：</p>
<p>天然解决锁释放问题（临时节点在会话结束自动删除）<br>通过Watcher机制避免轮询，性能较好<br>可靠性高</p>
<h3 id="三、问题与解决方案类"><a href="#三、问题与解决方案类" class="headerlink" title="三、问题与解决方案类"></a>三、问题与解决方案类</h3><ol>
<li>分布式锁的死锁问题如何解决？<br>答案：<br>死锁场景：<br>客户端获取锁后崩溃，没有释放锁，其他客户端永远无法获取锁。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>设置锁超时时间（Redis的expire，ZK的临时节点）</p>
</li>
<li><p>设置合理的超时时间，防止业务未完成锁就过期</p>
</li>
<li><p>实现锁续约机制（看门狗机制），业务执行期间定期延长锁时间</p>
</li>
<li><p>如何处理锁被其他客户端误删？<br>答案：<br>场景：<br>客户端A获取锁，执行时间过长导致锁过期自动释放，客户端B获取锁，此时A执行完释放锁，误删了B的锁。</p>
</li>
</ol>
<p>解决方案：</p>
<ul>
<li>锁value设置为唯一标识（如UUID）</li>
<li>释放锁时先检查value是否匹配</li>
<li><strong>Redis中使用Lua脚本保证检查+删除的原子性</strong></li>
</ul>
<ol start="3">
<li>如何实现可重入分布式锁？<br>答案：<br>原理：<br>同一个线程可以多次获取同一把锁，需要记录持有锁的线程和重入次数。</li>
</ol>
<p>实现方式：</p>
<ul>
<li>Redis实现：使用Hash结构，field为线程标识，value为重入次数</li>
<li>ZK实现：在节点数据中记录线程信息和重入次数</li>
<li>每次重入时增加计数，释放时减少计数，计数为0时真正释放</li>
</ul>
<h3 id="四、高级话题类"><a href="#四、高级话题类" class="headerlink" title="四、高级话题类"></a>四、高级话题类</h3><ol>
<li>分布式锁在CAP理论中的取舍<br>答案：</li>
</ol>
<p>CP系统（如Zookeeper）：优先保证一致性和分区容错性，牺牲部分可用性<br>AP系统（如Redis）：优先保证可用性和分区容错性，牺牲强一致性<br>选择依据：</p>
<p>强一致性需求高选ZK<br>高可用需求高选Redis<br>极端场景可用RedLock折中<br>2. 如何设计一个高可用的分布式锁服务？<br>答案：<br>设计要点：</p>
<p>多实例部署：避免单点故障<br>故障自动转移：主从切换<br>监控告警：锁等待时间、获取失败率等<br>降级方案：锁服务不可用时本地锁或排队机制<br>性能优化：避免锁成为系统瓶颈<br>3. 分布式锁与分布式事务的关系<br>答案：<br>区别：</p>
<p>分布式锁：解决资源互斥访问问题<br>分布式事务：保证跨服务的数据一致性<br>联系：</p>
<p>分布式事务中可能会用到分布式锁来保证资源隔离性<br>但分布式锁不能替代分布式事务，它只是其中一个工具<br>五、实战场景类</p>
<ol>
<li>秒杀系统中如何使用分布式锁？<br>答案：<br>典型场景：<br>防止超卖，保证库存扣减的原子性。</li>
</ol>
<p>实现方案：</p>
<p>用户下单时先获取商品ID对应的分布式锁<br>查询并校验库存<br>扣减库存<br>释放锁<br>优化点：</p>
<p>锁粒度要细（按商品ID加锁）<br>锁等待时间设置合理（避免长时间阻塞）<br>可采用分段锁提升并发性能<br>2. 分布式锁在缓存更新中的应用<br>答案：<br>缓存击穿场景：<br>热点key过期，大量请求同时访问数据库。</p>
<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">value = cache.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 再次检查，防止其他线程已经更新</span></span><br><span class="line">            value = cache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                value = db.get(key);</span><br><span class="line">                cache.set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，短暂等待后重试或返回旧值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>如何选择合适的分布式锁实现？<br>答案：<br>选择依据：</li>
</ol>
<p>Redis：<br>适合性能要求高、允许偶尔锁失效的场景<br>需要自己处理锁超时、续约等问题<br>集群环境下可用RedLock算法<br>Zookeeper：<br>适合强一致性要求的场景<br>可靠性高，但性能相对较低<br>适合锁竞争不激烈的场景<br>数据库：<br>适合简单场景，系统规模不大<br>不需要引入额外中间件<br>性能最差，不推荐高并发场景</p>
<h2 id="黑马点评项目"><a href="#黑马点评项目" class="headerlink" title="黑马点评项目"></a>黑马点评项目</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/KNeeg_/article/details/146123658">黑马点评完整代码(RabbitMQ优化)+简历编写+面试重点 ⭐_黑马点评简历-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">TTDB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/">http://example.com/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">TTDB's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/0ed4d56b723a59b4303d73913cf16f7.jpg" target="_blank"><img class="post-qr-code-img" src="/img/0ed4d56b723a59b4303d73913cf16f7.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/8151e0eadcb22bce884312f7f78e0f6.jpg" target="_blank"><img class="post-qr-code-img" src="/img/8151e0eadcb22bce884312f7f78e0f6.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/08/%E8%8B%A5%E4%BE%9D/" title="RuoYi"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RuoYi</div></div><div class="info-2"><div class="info-item-1">框架在线笔记基础应用篇：https://ksg50j5gph.feishu.cn/docx/LBpldchP4oGT9JxfaaQcT8hfnGd?from=from_copylink 项目实战篇：https://ksg50j5gph.feishu.cn/docx/NxIqdCZVzo2tRfxNL6Nc1BD1nnf?from=from_copylink 拔高原理篇：https://ksg50j5gph.feishu.cn/docx/DKoFdbI1ooYnBLxnw8mco9bgnvh?from=from_copylink </div></div></div></a><a class="pagination-related" href="/2025/07/14/git/" title="git使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">git使用</div></div><div class="info-2"><div class="info-item-1">gitgit 推送因合并冲突被拒绝. 本地缓存未刷新 虽然 git pull 显示最新，但可能本地缓存未正确更新。尝试： 123# 强制拉取远程分支覆盖本地（谨慎使用，会丢弃本地未提交修改）git fetch --allgit reset --hard origin/hgn  然后重新提交你的修改并推送： 123git add src/META-INF/ #添加到暂存区git commit -m &quot;添加 META-INF 目录&quot;git push origin hgn  git提交文件过大，暂存区无法提交git查看历史提交 1git log --oneline  重置分支到目标提交, abc1234是上一个命令的id 1git reset --hard abc1234  # 丢弃此提交之后的所有历史  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/21/%E9%9D%A2%E8%AF%95/" title="面试---java基础(待整理)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="info-item-2">面试---java基础(待整理)</div></div><div class="info-2"><div class="info-item-1">一、java基础java特点 平台无关性 面向对象：OOP 内存管理  跨平台java跨平台主要依赖与JVM Jvm JVM是一个软件由C&#x2F;C++开发，本身是编译后的机器码，不支持跨平台，需要安装不同版本的JDK JVM可以将字节码文件翻译成机器码，从而运行java程序，于是就有了： 我们编写的Java源码，编译后会生成一种 .class...</div></div></div></a><a class="pagination-related" href="/2025/08/12/redis%E9%9D%A2%E8%AF%95/" title="redis面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">redis面试</div></div><div class="info-2"><div class="info-item-1">为什么你的项目需要用到redis，高并发下有的项目也可以不用redis，mysql也行，淘宝是怎么做的redis最大的作用就是增加我的访问性能， 解决在海量数据下Mysql响应慢 项目中使用Redis，主要考虑性能和并发。其实不是所有的场景都要上Redis，如果仅仅是分布式锁这些，完全可以用中间件Zookpeer等代替。很多业务系统其实用数据库就够了，无脑上缓存&#x2F;NOSQL可能会带来更多更严重的问题。 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库 redis五种数据结构应用场景stringstring是一个K,V结构  通常用来缓存对象 stenx实现一个分布式锁 实现一个共享session，用户登录生成一个token，以用户信息为V,加上一个过期时间存放到redis中，访问刷新时间 计数器，记录网页的访问量或者是视频的播放次数，以网页路径或者视频id作为key，次数为value, 可以用来做一个限流，到达阈值就拒绝请求（ps：计数器限流的一个问题,...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TTDB</div><div class="author-info-description">What can I do for you?</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/HgnGoning" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hgn314134@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%89%88"><span class="toc-number">1.</span> <span class="toc-text">第一版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">Redis 相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">Redis 是用来做什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">缓存穿透是怎么解决的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">缓存击穿是怎么解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据一致性是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">redis持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.</span> <span class="toc-text">内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8D%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 不淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9A%8F%E6%9C%BA%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 随机淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LRU%E7%9B%B8%E5%85%B3%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. LRU相关策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LFU%E7%9B%B8%E5%85%B3%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. LFU相关策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TTL%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. TTL淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-%E4%B8%8E-LFU-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">LRU 与 LFU 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLRU%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">近似LRU实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLFU%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">近似LFU实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elasticsearch"><span class="toc-number">1.6.</span> <span class="toc-text">Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch-%E6%98%AF%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">Elasticsearch 是怎么提高检索效率的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MinIO"><span class="toc-number">1.7.</span> <span class="toc-text">MinIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-Resumable-Upload-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">断点续传 (Resumable Upload) 是如何实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">1.8.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8RabbitMQ%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E4%BC%98%E5%8C%96%E4%BB%A3%E9%87%91%E5%88%B8%E6%8A%A2%E8%B4%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">你是如何使用RabbitMQ进行流量削峰优化代金券抢购的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86%E6%9C%AA%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%EF%BC%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">如何基于延迟队列处理未支付订单？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.9.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.10.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%8A%A0-XXL-Job-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">1.11.</span> <span class="toc-text">基于本地消息表加 XXL-Job 任务调度实现分布式事务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.11.1.</span> <span class="toc-text">问题1：什么是分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.11.2.</span> <span class="toc-text">问题2：分布式事务控制的方案有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%8A%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%8C%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">1.11.3.</span> <span class="toc-text">问题3：如何使用本地消息表加任务调度完成分布式事务控制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XXL-Job"><span class="toc-number">1.12.</span> <span class="toc-text">**XXL-Job **</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9Axxl-job%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fxxl-job%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">问题1：xxl-job的工作原理是什么？xxl-job是什么怎么工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%BB%E5%8A%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">1.12.2.</span> <span class="toc-text">问题2：如何保证任务不重复执行?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-number">1.12.3.</span> <span class="toc-text">问题3：任务幂等性如何保证？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%984%EF%BC%9A%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8xxl-job%E8%BF%9B%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.12.4.</span> <span class="toc-text">问题4：你们项目如何使用xxl-job进行任务调度?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%985-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%A4%B1%E8%B4%A5%E6%AC%A1%E6%95%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.12.5.</span> <span class="toc-text">问题5: 任务处理达到最大失败次数怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%986-%E5%A6%82%E6%9E%9C%E4%BB%BB%E5%8A%A1%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.12.6.</span> <span class="toc-text">问题6: 如果任务一直没有完成怎么办？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.13.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80"><span class="toc-number">1.13.1.</span> <span class="toc-text">一、基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E7%B1%BB"><span class="toc-number">1.13.2.</span> <span class="toc-text">二、实现方案类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%B1%BB"><span class="toc-number">1.13.3.</span> <span class="toc-text">三、问题与解决方案类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98%E7%B1%BB"><span class="toc-number">1.13.4.</span> <span class="toc-text">四、高级话题类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.14.</span> <span class="toc-text">黑马点评项目</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/28/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="java设计模式">java设计模式</a><time datetime="2025-08-28T02:17:17.860Z" title="发表于 2025-08-28 10:17:17">2025-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="牛客面试题">牛客面试题</a><time datetime="2025-08-13T11:41:32.784Z" title="发表于 2025-08-13 19:41:32">2025-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/12/redis%E9%9D%A2%E8%AF%95/" title="redis面试">redis面试</a><time datetime="2025-08-12T02:06:27.028Z" title="发表于 2025-08-12 10:06:27">2025-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/06/java%E9%9B%86%E5%90%88/" title="java集合">java集合</a><time datetime="2025-08-06T03:16:04.399Z" title="发表于 2025-08-06 11:16:04">2025-08-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/14/git/" title="git使用">git使用</a><time datetime="2025-07-14T01:26:20.904Z" title="发表于 2025-07-14 09:26:20">2025-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By TTDB</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>