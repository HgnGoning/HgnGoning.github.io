<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试---java基础(待整理) | TTDB's blog</title><meta name="author" content="TTDB"><meta name="copyright" content="TTDB"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、java基础java特点 平台无关性 面向对象：OOP 内存管理  跨平台java跨平台主要依赖与JVM Jvm JVM是一个软件由C&#x2F;C++开发，本身是编译后的机器码，不支持跨平台，需要安装不同版本的JDK JVM可以将字节码文件翻译成机器码，从而运行java程序，于是就有了： 我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字">
<meta property="og:type" content="article">
<meta property="og:title" content="面试---java基础(待整理)">
<meta property="og:url" content="http://example.com/2025/04/21/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="TTDB&#39;s blog">
<meta property="og:description" content="一、java基础java特点 平台无关性 面向对象：OOP 内存管理  跨平台java跨平台主要依赖与JVM Jvm JVM是一个软件由C&#x2F;C++开发，本身是编译后的机器码，不支持跨平台，需要安装不同版本的JDK JVM可以将字节码文件翻译成机器码，从而运行java程序，于是就有了： 我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg">
<meta property="article:published_time" content="2025-04-21T06:26:10.376Z">
<meta property="article:modified_time" content="2025-08-28T02:30:18.029Z">
<meta property="article:author" content="TTDB">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试---java基础(待整理)",
  "url": "http://example.com/2025/04/21/%E9%9D%A2%E8%AF%95/",
  "image": "http://example.com/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg",
  "datePublished": "2025-04-21T06:26:10.376Z",
  "dateModified": "2025-08-28T02:30:18.029Z",
  "author": [
    {
      "@type": "Person",
      "name": "TTDB",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/21/%E9%9D%A2%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试---java基础(待整理)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/e93f858d798bea4fbdee83331ff488c.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">TTDB's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">面试---java基础(待整理)</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试---java基础(待整理)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-21T06:26:10.376Z" title="发表于 2025-04-21 14:26:10">2025-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T02:30:18.029Z" title="更新于 2025-08-28 10:30:18">2025-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">java后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h1><h2 id="java特点"><a href="#java特点" class="headerlink" title="java特点"></a>java特点</h2><ul>
<li>平台无关性</li>
<li>面向对象：OOP</li>
<li>内存管理</li>
</ul>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>java跨平台主要依赖与JVM</p>
<h3 id="Jvm"><a href="#Jvm" class="headerlink" title="Jvm"></a>Jvm</h3><ul>
<li>JVM是一个软件由C&#x2F;C++开发，本身是编译后的机器码，不支持跨平台，需要安装不同版本的JDK</li>
<li>JVM可以将字节码文件翻译成机器码，从而运行java程序，于是就有了：<ul>
<li>我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</li>
<li>编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</li>
</ul>
</li>
</ul>
<h3 id="JVM、JDK、JRE"><a href="#JVM、JDK、JRE" class="headerlink" title="JVM、JDK、JRE"></a>JVM、JDK、JRE</h3><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250418201441974.png" alt="image-20250418201441974"></p>
<p>它们之间的关系如下：</p>
<ul>
<li><strong>JVM是Java虚拟机，是Java程序运行的环境</strong>。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li>
<li><strong>JRE是Java运行时环境，是Java程序运行所需的最小环境</strong>。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li>
<li><strong>JDK是Java开发工具包，是开发Java程序所需的工具集合</strong>。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li>
</ul>
<h3 id="解释和编译"><a href="#解释和编译" class="headerlink" title="解释和编译"></a>解释和编译</h3><ul>
<li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。</li>
<li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</li>
<li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li>
</ul>
<p><strong>java既有解释也有编译</strong></p>
<p><strong>编译性</strong>：</p>
<ul>
<li>Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。</li>
</ul>
<p><strong>解释性：</strong></p>
<ul>
<li>JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li>
</ul>
<p>所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。</p>
<h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250418201708553.png" alt="image-20250418201708553"></p>
<p>注意一下几点：</p>
<ul>
<li>Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li>
<li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li>
<li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li>
<li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li>
<li>char类型是无符号的，不能为负，所以是0开始的</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><ul>
<li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将<code>int</code>转换为<code>long</code>、将<code>float</code>转换为<code>double</code>等。</li>
<li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将<code>long</code>转换为<code>int</code>、将<code>double</code>转换为<code>int</code>等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。</li>
<li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型<code>int</code>，可以使用<code>Integer.parseInt()</code>方法；将字符串转换为浮点型<code>double</code>，可以使用<code>Double.parseDouble()</code>方法等。</li>
<li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如<code>Character</code>类、<code>Integer</code>类等提供了相应的转换方法。</li>
</ul>
<h3 id="转换问题"><a href="#转换问题" class="headerlink" title="转换问题"></a>转换问题</h3><ul>
<li>数据丢失：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如，将一个<code>long</code>类型的值转换为<code>int</code>类型时，如果<code>long</code>值超出了<code>int</code>类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。</li>
<li>数据溢出：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如，将一个<code>int</code>类型的值转换为<code>long</code>类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。</li>
<li>精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(<code>float</code>)转换为双精度浮点数(<code>double</code>)时，精度可能会损失。</li>
<li>类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。</li>
</ul>
<h2 id="bigDecimal-和-double"><a href="#bigDecimal-和-double" class="headerlink" title="bigDecimal 和 double"></a>bigDecimal 和 double</h2><p>double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1&#x2F;3(1&#x2F;3&#x3D;0.3333…)，也就是说二进制表示小数的时候只能够表示能够用1&#x2F;(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1&#x2F;(2^n)的和的形式。</p>
<p>使用<code>BigDecimal</code>可以确保精确的十进制数值计算，避免了使用<code>double</code>可能出现的舍入误差。需要注意的是，在创建<code>BigDecimal</code>对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。</p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱（Boxing）和拆箱（Unboxing）是将<strong>基本数据类型</strong>和<strong>对应的包装类</strong>之间进行转换的过程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h2 id="Integer和int"><a href="#Integer和int" class="headerlink" title="Integer和int"></a>Integer和int</h2><p>Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。</p>
<p>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p>
<h3 id="泛型中的应用"><a href="#泛型中的应用" class="headerlink" title="泛型中的应用"></a><em>泛型中的应用</em></h3><p>在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。</p>
<p>例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="转换中的应用"><a href="#转换中的应用" class="headerlink" title="转换中的应用"></a><em>转换中的应用</em></h3><p>在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> integer.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<h3 id="集合中的应用"><a href="#集合中的应用" class="headerlink" title="集合中的应用"></a><em>集合中的应用</em></h3><p>Java集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().mapToInt(Integer::intValue).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>int是Java中的原始数据类型，而Integer是int的包装类。</p>
<p>Integer和 int 的区别：</p>
<ul>
<li>基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。</li>
<li>自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。</li>
<li>空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。</li>
</ul>
<p>差异：</p>
<ul>
<li>int基本类型数据在读写效率方面，要比包装类高效</li>
<li>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。</li>
<li>默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="怎么理解面向对象？简单说说封装继承多态"><a href="#怎么理解面向对象？简单说说封装继承多态" class="headerlink" title="怎么理解面向对象？简单说说封装继承多态"></a>怎么理解面向对象？简单说说封装继承多态</h3><p>面向对象是一种编程范式，它<strong>将现实世界中的事物抽象为对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p>
<p>Java面向对象的三大特性包括：<strong>封装、继承、多态</strong>：</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。</li>
<li><strong>继承</strong>：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li>
<li><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态在面向对象编程中可以体现在以下几个方面：</p>
<ul>
<li>方法重载：<ul>
<li>方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。</li>
<li>示例：对于一个 <code>add</code> 方法，可以定义为 <code>add(int a, int b)</code> 和 <code>add(double a, double b)</code>。</li>
</ul>
</li>
<li>方法重写：<ul>
<li>方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。</li>
<li>示例：在一个动物类中，定义一个 <code>sound</code> 方法，子类 <code>Dog</code> 可以重写该方法以实现 <code>bark</code>，而 <code>Cat</code> 可以实现 <code>meow</code>。</li>
</ul>
</li>
<li>接口与实现：<ul>
<li>多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。</li>
<li>示例：多个类（如 <code>Dog</code>, <code>Cat</code>）都实现了一个 <code>Animal</code> 接口，当用 <code>Animal</code> 类型的引用来调用 <code>makeSound</code> 方法时，会触发对应的实现。</li>
</ul>
</li>
<li>向上转型和向下转型：<ul>
<li>在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。</li>
<li>向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 <code>ClassCastException</code>。</li>
</ul>
</li>
</ul>
<h4 id="多态解决了什么问题？"><a href="#多态解决了什么问题？" class="headerlink" title="多态解决了什么问题？"></a>多态解决了什么问题？</h4><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。</p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等</p>
<h3 id="面向对象的设计原则你知道有哪些吗"><a href="#面向对象的设计原则你知道有哪些吗" class="headerlink" title="面向对象的设计原则你知道有哪些吗"></a>面向对象的设计原则你知道有哪些吗</h3><p>面向对象编程中的六大原则：</p>
<ul>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li>
<li><strong>里氏替换原则（LSP）</strong>：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li>
<li><strong>最少知识原则 (Law of Demeter)</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。</li>
</ul>
<h2 id="重载与重写有什么区别"><a href="#重载与重写有什么区别" class="headerlink" title="重载与重写有什么区别"></a>重载与重写有什么区别</h2><ul>
<li>重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），<strong>编译器根据调用时的参数类型来决定调用哪个方法</strong>。</li>
<li>重写（Overriding）指的是<strong>子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@override注解来明确表示这是对父类方法的重写</strong>。</li>
</ul>
<p>重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。一般继承一个接口之后就需要用到@override注解来实现方法</p>
<h2 id="抽象类和普通类区别"><a href="#抽象类和普通类区别" class="headerlink" title="抽象类和普通类区别"></a>抽象类和普通类区别</h2><ul>
<li>实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。</li>
<li>方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。</li>
<li>继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。</li>
<li>实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。</li>
</ul>
<h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p><strong>两者的特点：</strong></p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。</li>
</ul>
<p><strong>两者的区别：</strong></p>
<ul>
<li>实现方式：实现接口的关键字为<strong>implements</strong>，继承抽象类的关键字为<strong>extends</strong>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li>方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li>
<li>访问修饰符：<strong>接口成员变量默认为public static final，必须赋初值，不能被修改</strong>；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li>
<li>变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。</li>
</ul>
<h3 id="抽象类不能加final修饰"><a href="#抽象类不能加final修饰" class="headerlink" title="抽象类不能加final修饰"></a>抽象类不能加final修饰</h3><p><strong>不能</strong>，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p>
<h2 id="接口里面可以定义哪些方法"><a href="#接口里面可以定义哪些方法" class="headerlink" title="接口里面可以定义哪些方法"></a>接口里面可以定义哪些方法</h2><ul>
<li><p><strong>抽象方法</strong></p>
</li>
<li><p><strong>默认方法</strong></p>
</li>
<li><p><strong>静态方法</strong></p>
</li>
<li><p><strong>私有方法</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;<span class="comment">//抽象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;<span class="comment">//默认</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;<span class="comment">//静态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();<span class="comment">//调用私有</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;<span class="comment">//私有</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p>
<p>为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用</p>
<h2 id="抽象类可以被实例化吗"><a href="#抽象类可以被实例化吗" class="headerlink" title="抽象类可以被实例化吗"></a>抽象类可以被实例化吗</h2><p>在Java中，抽象类本身不能被实例化。</p>
<p>这意味着不能使用<code>new</code>关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由<code>abstract</code>关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。</p>
<h2 id="解释Java中的静态变量和静态方法"><a href="#解释Java中的静态变量和静态方法" class="headerlink" title="解释Java中的静态变量和静态方法"></a>解释Java中的静态变量和静态方法</h2><p>在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</p>
<p><strong>静态变量</strong>（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次分配内存。</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</li>
</ul>
<p><strong>静态方法</strong>是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</li>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li>
</ul>
<blockquote>
<p>使用场景</p>
</blockquote>
<ul>
<li><strong>静态变量</strong>：常用于需要在所有对象间共享的数据，如计数器、常量等。</li>
<li><strong>静态方法</strong>：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。</li>
</ul>
<h2 id="非静态内部类和静态内部类的区别"><a href="#非静态内部类和静态内部类的区别" class="headerlink" title="非静态内部类和静态内部类的区别"></a>非静态内部类和静态内部类的区别</h2><p>区别包括：</p>
<ul>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li>
<li><strong>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</strong></li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li>
</ul>
<h2 id="非静态内部类可以直接访问外部方法，编译器是怎么做到的"><a href="#非静态内部类可以直接访问外部方法，编译器是怎么做到的" class="headerlink" title="非静态内部类可以直接访问外部方法，编译器是怎么做到的"></a>非静态内部类可以直接访问外部方法，编译器是怎么做到的</h2><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p>
<p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</p>
<h3 id="编译器实现原理"><a href="#编译器实现原理" class="headerlink" title="编译器实现原理"></a>编译器实现原理</h3><ol>
<li><strong>自动添加外部类引用</strong>：<ul>
<li>编译器会在非静态内部类中自动添加一个指向外部类实例的final引用字段（通常命名为<code>this$0</code>）</li>
<li>这个引用在内部类实例化时被初始化</li>
</ul>
</li>
<li><strong>构造方法修改</strong>：<ul>
<li>编译器会修改内部类的构造方法，增加一个外部类实例参数</li>
<li>这个参数用于初始化<code>this$0</code>字段</li>
</ul>
</li>
<li><strong>访问外部成员时的转换</strong>：<ul>
<li>当内部类访问外部类的成员时，编译器会自动通过<code>this$0</code>引用访问</li>
<li>例如<code>outerMethod()</code>会被转换为<code>this$0.outerMethod()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(x); <span class="comment">// 直接访问外部类字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器处理后大致相当于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Outer <span class="built_in">this</span>$<span class="number">0</span>;  <span class="comment">// 自动添加的引用</span></span><br><span class="line">        </span><br><span class="line">        Inner(Outer outer) &#123;         <span class="comment">// 修改后的构造方法</span></span><br><span class="line">            <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = outer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>$<span class="number">0.</span>x); <span class="comment">// 通过引用访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-中-final-作用是什么"><a href="#Java-中-final-作用是什么" class="headerlink" title="Java 中 final 作用是什么"></a>Java 中 final 作用是什么</h2><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类、方法和变量。</p>
<ul>
<li>修饰类：当<code>final</code>修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的<code>String</code>类就是用<code>final</code>修饰的，这保证了<code>String</code>类的不可变性和安全性，防止其他类通过继承来改变<code>String</code>类的行为和特性。</li>
<li>修饰方法：用<code>final</code>修饰的方法不能在子类中被重写。比如，<code>java.lang.Object</code>类中的<code>getClass</code>方法就是<code>final</code>的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。</li>
<li>修饰变量：当<code>final</code>修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。例如，<code>final int num = 10;</code>，这里的<code>num</code>就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。对于引用数据类型，<code>final</code>修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如，<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让<code>sb</code>再指向其他<code>StringBuilder</code>对象，但可以通过<code>sb.append(&quot; World&quot;);</code>来修改字符串的内容。</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419092946232.png" alt="image-20250419092946232"></p>
<ul>
<li>浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。</li>
<li>深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象</li>
</ul>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul>
<li><em>实现 Cloneable 接口并重写 clone() 方法</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用序列化和反序列化</p>
</blockquote>
<p>通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>手动递归复制</p>
</blockquote>
<p>针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p>
</li>
<li><p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。</p>
</li>
</ul>
<h3 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h3><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法。<strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure>

<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入泛型，它将提供类型的约束，提供编译前的检查：&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="java创建对象有哪些方式"><a href="#java创建对象有哪些方式" class="headerlink" title="java创建对象有哪些方式"></a>java创建对象有哪些方式</h3><ul>
<li><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用clone()方法</strong>：如果类实现了Cloneable接口，可以使用clone()方法复制对象。<ul>
<li>所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。<ul>
<li>通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SerializedObject.java</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeserializedObject.java</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h3 id="New出的对象什么时候回收"><a href="#New出的对象什么时候回收" class="headerlink" title="New出的对象什么时候回收"></a>New出的对象什么时候回收</h3><p>通过过关键字<code>new</code>创建的对象，由Java的<strong>垃圾回收器</strong>（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会<strong>周期性地检测不再被引用的对象，并将其回收释放内存</strong>。</p>
<p>具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li>引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li>
<li>可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li>
<li>终结器（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。</li>
</ol>
<h3 id="如何获取私有对象"><a href="#如何获取私有对象" class="headerlink" title="如何获取私有对象"></a>如何获取私有对象</h3><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code> 的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问。</p>
<p>不过，可以通过下面两种方式来间接获取私有对象。</p>
<ul>
<li>使用公共访问器方法（getter 方法）：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 <code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共的 getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrivateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> privateField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 通过调用 getter 方法获取私有对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> obj.getPrivateField();</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        privateField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取私有字段的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj);</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射*"></a>反射*</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p><strong>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</strong></p>
<p>反射具有以下特性：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li>
<li><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</li>
<li><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</li>
<li><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</li>
</ol>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419094125221.png" alt="image-20250419094125221"></p>
<h3 id="反射在你平时写代码或者框架中的应用场景有哪些"><a href="#反射在你平时写代码或者框架中的应用场景有哪些" class="headerlink" title="反射在你平时写代码或者框架中的应用场景有哪些"></a>反射在你平时写代码或者框架中的应用场景有哪些</h3><blockquote>
<p>加载数据库驱动</p>
</blockquote>
<p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection,com.mikechen.java.oracleConnection这两个类我们要用。</p>
<p>这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置文件加载</p>
</blockquote>
<p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>
<p>Spring通过XML配置模式装载Bean的过程：</p>
<ul>
<li>将程序中所有XML或properties配置文件加载入内存</li>
<li>Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的Class实例</li>
<li>动态配置实例的属性</li>
</ul>
<p>配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure>

<p>实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析配置文件内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestInvoke</span><br><span class="line">I am fine</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Java注解的原理"><a href="#Java注解的原理" class="headerlink" title="Java注解的原理"></a>Java注解的原理</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p>
<p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h3 id="注解解析的底层实现"><a href="#注解解析的底层实现" class="headerlink" title="注解解析的底层实现"></a>注解解析的底层实现</h3><p>注解本质上是一种特殊的接口，它继承自 <code>java.lang.annotation.Annotation</code> 接口，<strong>所以注解也叫声明式接口</strong>，例如，定义一个简单的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，Java 编译器会将其转换为一个继承自 <code>Annotation</code> 的接口，并生成相应的字节码文件。</p>
<p>根据注解的作用范围，Java 注解可以分为以下几种类型：</p>
<ul>
<li><strong>源码级别注解</strong> ：仅存在于源码中，编译后不会保留（<code>@Retention(RetentionPolicy.SOURCE)</code>）。</li>
<li><strong>类文件级别注解</strong> ：保留在 <code>.class</code> 文件中，但运行时不可见（<code>@Retention(RetentionPolicy.CLASS)</code>）。</li>
<li><strong>运行时注解</strong> ：保留在 <code>.class</code> 文件中，并且可以通过反射在运行时访问（<code>@Retention(RetentionPolicy.RUNTIME)</code>）。</li>
</ul>
<p>只有运行时注解可以通过反射机制进行解析。</p>
<p>当注解被标记为 <code>RUNTIME</code> 时，Java 编译器会在生成的 <code>.class</code> 文件中保存注解信息。这些信息存储在字节码的属性表（Attribute Table）中，具体包括以下内容：</p>
<ul>
<li><strong>RuntimeVisibleAnnotations</strong> ：存储运行时可见的注解信息。</li>
<li><strong>RuntimeInvisibleAnnotations</strong> ：存储运行时不可见的注解信息。</li>
<li><strong>RuntimeVisibleParameterAnnotations</strong> 和 <strong>RuntimeInvisibleParameterAnnotations</strong> ：存储方法参数上的注解信息。</li>
</ul>
<p>通过工具（如 <code>javap -v</code>）可以查看 <code>.class</code> 文件中的注解信息。</p>
<p>注解的解析主要依赖于 Java 的反射机制。以下是解析注解的基本流程：</p>
<p>1、获取注册信息：通过反射 API 可以获取类、方法、字段等元素上的注解。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(annotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、底层原理：反射机制的核心类是 <code>java.lang.reflect.AnnotatedElement</code>，它是所有可以被注解修饰的元素（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 等）的父接口。该接口提供了以下方法：</p>
<ul>
<li><code>getAnnotation(Class&lt;T&gt; annotationClass)</code>：获取指定类型的注解。</li>
<li><code>getAnnotations()</code>：获取所有注解。</li>
<li><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>：判断是否包含指定注解。</li>
</ul>
<p>这些方法的底层实现依赖于 JVM 提供的本地方法（Native Method），例如：</p>
<ul>
<li><code>native Annotation[] getDeclaredAnnotations0(boolean publicOnly);</code></li>
<li><code>native &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass);</code></li>
</ul>
<p>JVM 在加载类时会解析 <code>.class</code> 文件中的注解信息，并将其存储在内存中，供反射机制使用。</p>
<p>因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值。</p>
<h3 id="Java注解的作用域"><a href="#Java注解的作用域" class="headerlink" title="Java注解的作用域"></a>Java注解的作用域</h3><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p>
<ol>
<li>类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</li>
<li>方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</li>
<li>字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</li>
</ol>
<p>除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><p>Java异常类层次结构图:</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419095159497.png" alt="image-20250419095159497"></p>
<p>Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。</p>
<ol>
<li><strong>Error（错误）</strong>：表示<strong>运行时环境的错误</strong>。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。</li>
<li><strong>Exception（异常）</strong>：表示<strong>程序本身可以处理的异常条件</strong>。异常分为两大类：<ul>
<li><strong>非运行时异常</strong>：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li>
<li><strong>运行时异常</strong>：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。</li>
</ul>
</li>
</ol>
<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p>
<ul>
<li>try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType3 e3) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionType(&quot;Exception message&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally块：<strong>用于定义无论是否发生异常都会执行的代码块</strong>。通常用于释放资源，确保资源的正确关闭。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="抛出异常为什么不用throws？"><a href="#抛出异常为什么不用throws？" class="headerlink" title="抛出异常为什么不用throws？"></a>抛出异常为什么不用throws？</h3><p>如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。</p>
<ul>
<li><strong>Unchecked Exceptions</strong>：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。</li>
<li><strong>捕获和处理异常</strong>：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。</li>
</ul>
<h3 id="try-catch中的语句运行情况"><a href="#try-catch中的语句运行情况" class="headerlink" title="try catch中的语句运行情况"></a>try catch中的语句运行情况</h3><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。</p>
<h3 id="try-return-“a”-fianlly-return-“b”-这条语句返回啥"><a href="#try-return-“a”-fianlly-return-“b”-这条语句返回啥" class="headerlink" title="try{return “a”} fianlly{return “b”}这条语句返回啥"></a>try{return “a”} fianlly{return “b”}这条语句返回啥</h3><p>finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。</p>
<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><h3 id="与-equals-有什么区别"><a href="#与-equals-有什么区别" class="headerlink" title="&#x3D;&#x3D; 与 equals 有什么区别"></a>&#x3D;&#x3D; 与 equals 有什么区别</h3><p>对于字符串变量来说，使用”&#x3D;&#x3D;”和”equals”比较字符串时，其比较方法不同。”&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址，”equals”比较字符串包含内容是否相同。</p>
<p>对于非字符串变量来说，如果没有对equals()进行重写的话，”&#x3D;&#x3D;” 和 “equals”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。</p>
<ul>
<li>&#x3D;&#x3D;：比较的是两个字符串<strong>内存地址（堆内存）的数值是否相等</strong>，属于数值比较；</li>
<li>equals()：比较的是两个<strong>字符串的内容</strong>，属于内容比较。</li>
</ul>
<h3 id="hashcode和equals方法有什么关系"><a href="#hashcode和equals方法有什么关系" class="headerlink" title="hashcode和equals方法有什么关系"></a>hashcode和equals方法有什么关系</h3><p>在 Java 中，对于重写 <code>equals</code> 方法的类，通常也需要重写 <code>hashCode</code> 方法，并且需要遵循以下规定：</p>
<ul>
<li><strong>一致性</strong>：如果两个对象使用 <code>equals</code> 方法比较结果为 <code>true</code>，那么它们的 <code>hashCode</code> 值必须相同。也就是说，如果 <code>obj1.equals(obj2)</code> 返回 <code>true</code>，那么 <code>obj1.hashCode()</code> 必须等于 <code>obj2.hashCode()</code>。</li>
<li><strong>非一致性</strong>：如果两个对象的 <code>hashCode</code> 值相同，它们使用 <code>equals</code> 方法比较的结果不一定为 <code>true</code>。即 <code>obj1.hashCode() == obj2.hashCode()</code> 时，<code>obj1.equals(obj2)</code> 可能为 <code>false</code>，这种情况称为<strong>哈希冲突</strong>。</li>
<li>equals为true，hashCode就一定为true。反之不然</li>
</ul>
<p><code>hashCode</code> 和 <code>equals</code> 方法是紧密相关的，重写 <code>equals</code> 方法时必须重写 <code>hashCode</code> 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 <code>hashCode</code> 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等。</p>
<h3 id="String、StringBuffer、StringBuilder的区别和联系"><a href="#String、StringBuffer、StringBuilder的区别和联系" class="headerlink" title="String、StringBuffer、StringBuilder的区别和联系"></a>String、StringBuffer、StringBuilder的区别和联系</h3><p><strong>1、可变性</strong> ：<code>String</code> 是<strong>不可变</strong>的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。<code>StringBuilder</code> 和 <code>StringBuffer</code> 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象。</p>
<p><strong>2、线程安全性</strong> ：<code>String</code> 因为不可变，天然线程安全。<code>StringBuilder</code> 不是线程安全的，适用于单线程环境。<code>StringBuffer</code> 是线程安全的，其方法通过 <code>synchronized</code> 关键字实现同步，适用于多线程环境。</p>
<p><strong>3、性能</strong> ：<code>String</code> 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。<code>StringBuilder</code> 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。<code>StringBuffer</code> 性能略低于 <code>StringBuilder</code>，因为它的线程安全机制引入了同步开销。</p>
<p><strong>4、使用场景</strong> ：如果字符串内容固定或不常变化，优先使用 <code>String</code>。如果需要频繁修改字符串且在单线程环境下，使用 <code>StringBuilder</code>。如果需要频繁修改字符串且在多线程环境下，使用 <code>StringBuffer</code>。</p>
<p>对比总结如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>String</strong></th>
<th><strong>StringBuilder</strong></th>
<th><strong>StringBuffer</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变性</strong></td>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（因不可变）</td>
<td>否</td>
<td>是（同步方法）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低（频繁修改时）</td>
<td>高（单线程）</td>
<td>中（多线程安全）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>静态字符串</td>
<td>单线程动态字符串</td>
<td>多线程动态字符串</td>
</tr>
</tbody></table>
<p>例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String的不可变性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot;def&quot;</span>; <span class="comment">// 新建对象，str指向新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder（单线程高效）</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;def&quot;</span>); <span class="comment">// 直接修改内部数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer（多线程安全）</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sbf.append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;def&quot;</span>); <span class="comment">// 同步方法保证线程安全</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-8新特性"><a href="#Java-8新特性" class="headerlink" title="Java 8新特性"></a>Java 8新特性</h2><table>
<thead>
<tr>
<th><strong>特性名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例或说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda 表达式</strong></td>
<td>简化匿名内部类，支持函数式编程</td>
<td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td>
</tr>
<tr>
<td><strong>函数式接口</strong></td>
<td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td>
<td><code>Runnable</code>, <code>Comparator</code>, 或自定义接口 <code>@FunctionalInterface interface MyFunc &#123; void run(); &#125;</code></td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>提供链式操作处理集合数据，支持并行处理</td>
<td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><strong>Optional 类</strong></td>
<td>封装可能为 <code>null</code> 的对象，减少空指针异常</td>
<td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td>
</tr>
<tr>
<td><strong>方法引用</strong></td>
<td>简化 Lambda 表达式，直接引用现有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
<tr>
<td><strong>接口的默认方法与静态方法</strong></td>
<td>接口可定义默认实现和静态方法，增强扩展性</td>
<td><code>interface A &#123; default void print() &#123; System.out.println(&quot;默认方法&quot;); &#125; &#125;</code></td>
</tr>
<tr>
<td><strong>并行数组排序</strong></td>
<td>使用多线程加速数组排序</td>
<td><code>Arrays.parallelSort(array)</code></td>
</tr>
<tr>
<td><strong>重复注解</strong></td>
<td>允许同一位置多次使用相同注解</td>
<td><code>@Repeatable</code> 注解配合容器注解使用</td>
</tr>
<tr>
<td><strong>类型注解</strong></td>
<td>注解可应用于更多位置（如泛型、异常等）</td>
<td><code>List&lt;@NonNull String&gt; list</code></td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>增强异步编程能力，支持链式调用和组合操作</td>
<td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td>
</tr>
</tbody></table>
<p>这些新特性用的也比较频繁<strong>Lambda 表达式</strong>、<strong>函数式接口</strong>、<strong>Stream API</strong>、<strong>方法引用</strong></p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式它是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：</p>
<ul>
<li><code>(parameters) -&gt; expression</code>：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值。</li>
<li><code>(parameters) -&gt; &#123; statements; &#125;</code>：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 <code>return</code> 语句。</li>
</ul>
<p>传统的<strong>匿名内部类</strong>实现方式代码较为冗长，而 Lambda 表达式可以用更简洁的语法实现相同的功能。比如，使用匿名内部类实现 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running using anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running using lambda expression&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Lambda 表达式的代码更加简洁明了。</p>
<p>还有，Lambda 表达式能够更清晰地表达代码的意图，尤其是在处理集合操作时，如过滤、映射等。比如，过滤出列表中所有偶数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadabilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式结合 Stream API 过滤偶数</span></span><br><span class="line">        List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                           .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line">        System.out.println(evenNumbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Lambda 表达式，代码的逻辑更加直观，易于理解。</p>
<p>还有，Lambda 表达式使得 Java 支持函数式编程范式，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。比如定义一个通用的计算函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalProgrammingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递加法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递乘法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Lambda 表达式优点蛮多的，不过也有一些缺点，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加。</p>
<h3 id="Java中stream的API"><a href="#Java中stream的API" class="headerlink" title="Java中stream的API"></a>Java中stream的API</h3><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理。让我们通过两个具体的例子来感受下Java Stream API带来的便利，对比在Stream API引入之前的传统做法。</p>
<blockquote>
<p>案例1：过滤并收集满足条件的元素</p>
</blockquote>
<p><strong>问题场景</strong>：从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用<code>.stream()</code>方法创建了一个流，使用<code>.filter()</code>中间操作筛选出长度大于3的字符串，最后使用<code>.collect(Collectors.toList())</code>终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。</p>
<blockquote>
<p>案例2：计算列表中所有数字的总和</p>
</blockquote>
<p><strong>问题场景</strong>：计算一个数字列表中所有元素的总和。</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过Stream API，我们可以先使用<code>.mapToInt()</code>将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用<code>.sum()</code>方法来计算总和，极大地简化了代码。</p>
<h3 id="Stream流的并行API-ParallelStream"><a href="#Stream流的并行API-ParallelStream" class="headerlink" title="Stream流的并行API - ParallelStream"></a>Stream流的并行API - ParallelStream</h3><p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果</p>
<p>Stream串行流与并行流的主要区别：</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419100411244.png" alt="image-20250419100411244"></p>
<p>对CPU<strong>密集型的任务</strong>来说，并行流使用ForkJoinPool<strong>线程池</strong>，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是<strong>I&#x2F;O密集</strong>的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择。</p>
<h3 id="completableFuture怎么用的"><a href="#completableFuture怎么用的" class="headerlink" title="completableFuture怎么用的"></a>completableFuture怎么用的</h3><p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p>
<ul>
<li>Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。</li>
<li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。</li>
</ul>
<p>下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。</p>
<p>Future(ListenableFuture)的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p>CompletableFuture的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，CompletableFuture的实现更为简洁，可读性更好。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419100506343.png" alt="image-20250419100506343"></p>
<p>CompletableFuture实现了两个接口（如上图所示)：Future、CompletionStage。</p>
<ul>
<li>Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</li>
</ul>
<h3 id="Java-21-新特性知道哪些？"><a href="#Java-21-新特性知道哪些？" class="headerlink" title="Java 21 新特性知道哪些？"></a>Java 21 新特性知道哪些？</h3><p><strong>新新语言特性：</strong></p>
<ul>
<li><strong>Switch 语句的模式匹配</strong>：该功能在 Java 21 中也得到了增强。它允许在<code>switch</code>的<code>case</code>标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如，对于不同类型的账户类，可以在<code>switch</code>语句中直接根据账户类型的模式来获取相应的余额，如<code>case savingsAccount sa -&gt; result = sa.getSavings();</code></li>
<li><strong>数组模式</strong>：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如，<code>if (arr instanceof int[] &#123;1, 2, 3&#125;)</code>，可以直接判断数组<code>arr</code>是否匹配指定的模式。</li>
<li><strong>字符串模板（预览版）</strong>：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用<code>&quot;hello &quot; + name + &quot;, welcome to the geeksforgeeks!&quot;</code>这样的方式来拼接字符串，在 Java 21 中可以使用<code>hello &#123;name&#125;, welcome to the geeksforgeeks!</code>这种更简洁的写法</li>
</ul>
<p><strong>新并发特性方面：</strong></p>
<ul>
<li><strong>虚拟线程</strong>：这是 Java 21 引入的一种轻量级并发的新选择。它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或<code>ExecutorService</code>来创建和使用虚拟线程。</li>
<li><strong>Scoped Values（范围值）</strong>：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="怎么把一个对象从一个jvm转移到另一个jvm?"></a>怎么把一个对象从一个jvm转移到另一个jvm?</h3><ul>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li>
</ul>
<h3 id="序列化和反序列化让你自己实现你会怎么做"><a href="#序列化和反序列化让你自己实现你会怎么做" class="headerlink" title="序列化和反序列化让你自己实现你会怎么做?"></a>序列化和反序列化让你自己实现你会怎么做?</h3><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。</p>
<ul>
<li>无法跨语言： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</li>
<li>容易被攻击：<strong>Java 序列化是不安全的</strong>，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。开发中常用JSON序列化，例如消息队队列放数据就是用JSON序列化</li>
<li>序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</li>
</ul>
<p>我会考虑用主流序列化框架，比如FastJson、Protobuf来替代Java 序列化。</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。</p>
<h3 id="将对象转为二进制字节流具体怎么实现"><a href="#将对象转为二进制字节流具体怎么实现" class="headerlink" title="将对象转为二进制字节流具体怎么实现?"></a>将对象转为二进制字节流具体怎么实现?</h3><p>其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。</p>
<p>在Java中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li>ObjectOutputStream：通过writeObject(）方法做序列化操作。</li>
<li>ObjectInputStrean：通过readObject()方法做反序列化操作。</li>
</ul>
<p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<p>实现对象序列化：</p>
<ul>
<li>让类实现Serializable接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现对象反序列化：</p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="volatile和sychronized如何实现单例模式"><a href="#volatile和sychronized如何实现单例模式" class="headerlink" title="volatile和sychronized如何实现单例模式"></a>volatile和sychronized如何实现单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字修饰变量 防止指令重排序</span></span><br><span class="line">    private <span class="keyword">static</span> volatile <span class="title class_">SingleTon</span> instance = <span class="literal">null</span>;</span><br><span class="line">    private <span class="title class_">SingleTon</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">static</span>  <span class="title class_">SingleTon</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块 只有在第一次获取对象的时候会执行到 ，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦</span></span><br><span class="line">            <span class="title function_">synchronized</span>(<span class="params">SingleTon.<span class="keyword">class</span></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。</p>
<ul>
<li>保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。</li>
<li>禁止指令重排序优化。</li>
</ul>
<p>由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p>
<h3 id="代理模式和适配器模式有什么区别？"><a href="#代理模式和适配器模式有什么区别？" class="headerlink" title="代理模式和适配器模式有什么区别？"></a>代理模式和适配器模式有什么区别？</h3><ul>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="Java怎么实现网络IO高并发编程"><a href="#Java怎么实现网络IO高并发编程" class="headerlink" title="Java怎么实现网络IO高并发编程"></a><strong>Java怎么实现网络IO高并发编程</strong></h3><p>可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419104337727.png" alt="image-20250419104337727"></p>
<p>NIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419104350400.png" alt="image-20250419104350400"></p>
<h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><ul>
<li>BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
<h3 id="NIO是怎么实现的"><a href="#NIO是怎么实现的" class="headerlink" title="NIO是怎么实现的"></a>NIO是怎么实现的</h3><ul>
<li>NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。</li>
<li>同步的核心就Selector（I&#x2F;O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。</li>
<li>NIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。</li>
<li>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</li>
<li>Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</li>
</ul>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419104522663.png" alt="image-20250419104522663"></p>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><strong>Netty</strong></h4><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419104610615.png" alt="image-20250419104610615">Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h3><p>可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加学生对象到列表中</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>

<h3 id="Native方法解释一下"><a href="#Native方法解释一下" class="headerlink" title="Native方法解释一下"></a>Native方法解释一下</h3><p>在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。</p>
<p>在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现native方法，你需要完成以下步骤：</p>
<ol>
<li><strong>生成JNI头文件</strong>：使用javah工具从你的Java类生成C&#x2F;C++的头文件，这个头文件包含了所有native方法的原型。</li>
<li><strong>编写本地代码</strong>：使用C&#x2F;C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。</li>
<li><strong>编译本地代码</strong>：将C&#x2F;C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）</li>
<li><strong>加载本地库</strong>：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。</li>
</ol>
<h1 id="二、java集合"><a href="#二、java集合" class="headerlink" title="二、java集合"></a>二、java集合</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="数组与集合区别？"><a href="#数组与集合区别？" class="headerlink" title="数组与集合区别？"></a>数组与集合区别？</h3><p>数组和集合的区别：</p>
<ul>
<li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</li>
<li>数组可以包含基本数据类型和对象，而集合只能包含对象。</li>
<li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li>
</ul>
<p>我用过的一些 Java 集合类：</p>
<ol>
<li><strong>ArrayList：</strong> 动态数组，实现了List接口，支持动态增长。</li>
<li><strong>LinkedList：</strong> 双向链表，也实现了List接口，支持快速的插入和删除操作。</li>
<li><strong>HashMap：</strong> 基于哈希表的Map实现，存储键值对，通过键快速查找值。</li>
<li><strong>HashSet：</strong> 基于HashMap实现的Set集合，用于存储唯一元素。</li>
<li><strong>TreeMap：</strong> 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。</li>
<li><strong>LinkedHashMap：</strong> 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。</li>
<li><strong>PriorityQueue：</strong> 优先队列，可以按照比较器或元素的自然顺序进行排序。</li>
</ol>
<h2 id="Java中的集合-Collection"><a href="#Java中的集合-Collection" class="headerlink" title="Java中的集合-Collection"></a>Java中的集合-Collection</h2><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419120631588.png" alt="image-20250419120631588"></p>
<p><strong>List是有序的Collection</strong>，使用此接口能够精确的控制每个元素的插入位置，用户能根据索引访问List中元素。常用的实现List的类有LinkedList，ArrayList，Vector，Stack。</p>
<ul>
<li>ArrayList是容量可变的非线程安全列表，其底层使用数组实现。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。ArrayList支持对元素的快速随机访问，但插入与删除速度很慢。</li>
<li>LinkedList本质是一个双向链表，与ArrayList相比，，其插入和删除速度更快，但随机访问速度更慢。</li>
</ul>
<p><strong>Set不允许存在重复的元素</strong>，与List不同，set中的元素是无序的。常用的实现有HashSet，LinkedHashSet和TreeSet。</p>
<ul>
<li>HashSet通过HashMap实现，HashMap的Key即HashSet存储的元素，所有Key都是用相同的Value，一个名为PRESENT的Object类型常量。使用Key保证元素唯一性，但不保证有序性。由于HashSet是HashMap实现的，因此线程不安全。</li>
<li>LinkedHashSet继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。</li>
<li>TreeSet通过TreeMap实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。</li>
</ul>
<p><strong>Map 是一个键值对集合，存储键、值和之间的映射</strong>。Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，只要给出键对象，就会返回对应的值对象。主要实现有TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>
<ul>
<li>HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将<strong>链表转化为红黑树</strong>，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>HashTable：数组+链表组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap：红黑树（自平衡的排序二叉树）</li>
<li>ConcurrentHashMap：Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）</li>
</ul>
<h2 id="Java中的线程安全的集合"><a href="#Java中的线程安全的集合" class="headerlink" title="Java中的线程安全的集合"></a>Java中的线程安全的集合</h2><p>在 java.util 包中的线程安全的类主要 2 个，其他都是非线程安全的。</p>
<ul>
<li><strong>Vector</strong>：线程安全的动态数组，其内部方法基本都经过synchronized修饰，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li>
<li><strong>Hashtable</strong>：线程安全的哈希表，HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用ConcurrentHashMap。</li>
</ul>
<p>java.util.concurrent 包提供的都是线程安全的集合：</p>
<p>并发Map：</p>
<ul>
<li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是二者加锁粒度的不同，在<strong>JDK1.7</strong>，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在<strong>JDK 1.8</strong> ，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。</li>
<li><strong>ConcurrentSkipListMap</strong>：实现了一个基于SkipList（跳表）算法的可排序的并发集合，SkipList是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。</li>
</ul>
<p>并发Set：</p>
<ul>
<li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li>
<li><strong>CopyOnWriteArraySet</strong>：是线程安全的Set实现，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。</li>
</ul>
<p>并发List：</p>
<ul>
<li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体，其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素。即当对象进行写操作时，使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步。</li>
</ul>
<p>并发 Queue：</p>
<ul>
<li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。</li>
<li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。BlockingQueue 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。</li>
</ul>
<p>并发 Deque：</p>
<ul>
<li><strong>LinkedBlockingDeque</strong>：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</li>
<li><strong>ConcurrentLinkedDeque</strong>：ConcurrentLinkedDeque是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，ConcurrentLinkedDeque是一个合适的选择。</li>
</ul>
<h2 id="Collections和Collection"><a href="#Collections和Collection" class="headerlink" title="Collections和Collection"></a>Collections和Collection</h2><ul>
<li>Collection是Java集合框架中的一个接口，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。</li>
<li>Collections（注意有一个s）是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</li>
</ul>
<h3 id="集合遍历的方法"><a href="#集合遍历的方法" class="headerlink" title="集合遍历的方法"></a>集合遍历的方法</h3><p>在Java中，集合的遍历方法主要有以下几种：</p>
<ul>
<li><strong>普通 for 循环：</strong> 可以使用带有索引的普通 for 循环来遍历 List。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>增强 for 循环（for-each循环）：</strong> 用于循环访问数组或集合中的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Iterator 迭代器：</strong> 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ListIterator 列表迭代器：</strong> ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">ListIterator&lt;String&gt; listIterator= list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 forEach 方法：</strong> Java 8引入了 forEach 方法，可以对集合进行快速遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Stream API：</strong> Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>

<p>这些是常用的集合遍历方法，根据情况选择合适的方法来遍历和操作集合。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419121149247.png" alt="image-20250419121149247"></p>
<p>常见的List集合（非线程安全）：</p>
<ul>
<li><code>ArrayList</code>基于动态数组实现，它允许<strong>快速的随机访问</strong>，即通过索引访问元素的时间复杂度为 O (1)。在添加和删除元素时，如果操作位置不是列表末尾，可能需要移动大量元素，性能相对较低。适用于需要频繁随机访问元素，而对插入和删除操作性能要求不高的场景，如数据的查询和展示等。</li>
<li><code>LinkedList</code>基于<strong>双向链表</strong>实现，在插入和删除元素时，只需修改链表的指针，不需要移动大量元素，时间复杂度为 O (1)。但随机访问元素时，需要从链表头或链表尾开始遍历，时间复杂度为 O (n)。适用于需要频繁进行插入和删除操作的场景，如队列、栈等数据结构的实现，以及需要在列表中间频繁插入和删除元素的情况。</li>
</ul>
<p>常见的List集合（线程安全）：</p>
<ul>
<li><code>Vector</code>和<code>ArrayList</code>类似，也是基于数组实现。<code>Vector</code>中的方法大多是同步的，这使得它在多线程环境下可以保证数据的一致性，但在单线程环境下，由于同步带来的开销，性能会略低于<code>ArrayList</code>。</li>
<li><code>CopyOnWriteArrayList</code>在对列表进行修改（如添加、删除元素）时，会<strong>创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然在原数组上进行，这样可以保证读操作不会被写操作阻塞，实现了读写分离，提高了并发性能</strong>。适用于读操作远远多于写操作的并发场景，如事件监听列表等，在这种场景下可以避免大量的锁竞争，提高系统的性能和响应速度。</li>
</ul>
<h3 id="java里面list的几种实现，几种实现有什么不同"><a href="#java里面list的几种实现，几种实现有什么不同" class="headerlink" title="java里面list的几种实现，几种实现有什么不同"></a>java里面list的几种实现，几种实现有什么不同</h3><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419121244304.png" alt="image-20250419121244304"></p>
<ul>
<li>Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li>
<li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</li>
<li>LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</li>
</ul>
<blockquote>
<p>这几种实现具体在什么场景下应该用哪种？</p>
</blockquote>
<ul>
<li>Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li>
<li>而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。</li>
</ul>
<h3 id="list可以一边遍历一边修改元素吗？"><a href="#list可以一边遍历一边修改元素吗？" class="headerlink" title="list可以一边遍历一边修改元素吗？"></a>list可以一边遍历一边修改元素吗？</h3><p>在 Java 中，<strong><code>List</code>在遍历过程中是否可以修改元素取决于遍历方式和具体的<code>List</code>实现类</strong>，以下是几种常见情况：</p>
<ul>
<li>使用普通for循环遍历：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用普通for循环遍历并修改元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用foreach循环遍历：一般<strong>不建议</strong>在<code>foreach</code>循环中直接修改正在遍历的<code>List</code>元素，因为这可能会导致意外的结果或<code>ConcurrentModificationException</code>异常。在<code>foreach</code>循环中修改元素可能会破坏迭代器的内部状态，因为<code>foreach</code>循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用foreach循环遍历并尝试修改元素，会抛出ConcurrentModificationException异常</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用迭代器遍历：可以使用迭代器的<code>remove</code>方法来删除元素，但如果要修改元素的值，需要通过迭代器的<code>set</code>方法来进行，而不是直接通过<code>List</code>的<code>set</code>方法，否则也可能会抛出<code>ConcurrentModificationException</code>异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历并修改元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用迭代器的set方法修改元素</span></span><br><span class="line">                iterator.set(<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程安全的<code>List</code>，如<code>CopyOnWriteArrayList</code>，由于其采用了写时复制的机制，在遍历的同时可以进行修改操作，不会抛出<code>ConcurrentModificationException</code>异常，但可能会读取到旧的数据，因为修改操作是在新的副本上进行的。</p>
<h3 id="list如何快速删除某个指定下标的元素"><a href="#list如何快速删除某个指定下标的元素" class="headerlink" title="list如何快速删除某个指定下标的元素"></a>list如何快速删除某个指定下标的元素</h3><p><code>ArrayList</code>提供了<code>remove(int index)</code>方法来删除指定下标的元素，该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。如果删除的是列表末尾的元素，时间复杂度为 O (1)；如果删除的是列表中间的元素，时间复杂度为 O (n)，n 为列表中元素的个数，因为需要移动后续的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除下标为1的元素</span></span><br><span class="line">       list.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>LinkedList</code>的<code>remove(int index)</code>方法也可以用来删除指定下标的元素。它需要先遍历到指定下标位置，然后修改链表的指针来删除元素。时间复杂度为 O (n)，n 为要删除元素的下标。不过，如果已知要删除的元素是链表的头节点或尾节点，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)。</p>
<p><code>opyOnWriteArrayList</code>的<code>remove</code>方法同样可以删除指定下标的元素。由于<code>CopyOnWriteArrayList</code>在写操作时会创建一个新的数组，所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)，n 为数组的长度。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能。</p>
<h3 id="Arraylist和LinkedList的区别，哪个集合是线程安全的？"><a href="#Arraylist和LinkedList的区别，哪个集合是线程安全的？" class="headerlink" title="Arraylist和LinkedList的区别，哪个集合是线程安全的？"></a>Arraylist和LinkedList的区别，哪个集合是线程安全的？</h3><p>ArrayList和LinkedList都是Java中常见的集合类，它们都实现了List接口。</p>
<ul>
<li><strong>底层数据结构不同</strong>：ArrayList使用数组实现，通过索引进行快速访问元素。LinkedList使用链表实现，通过节点之间的指针进行元素的访问和操作。</li>
<li><strong>插入和删除操作的效率不同</strong>：ArrayList在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低，需要移动元素。LinkedList在任意位置的插入和删除操作效率都比较高，因为只需要调整节点之间的指针，但是LinkedList是不支持随机访问的，所以除了头结点外插入和删除的时间复杂度都是0(n)，效率也不是很高所以LinkedList基本没人用。</li>
<li><strong>随机访问的效率不同</strong>：ArrayList支持通过索引进行快速随机访问，时间复杂度为O(1)。LinkedList需要从头或尾开始遍历链表，时间复杂度为O(n)。</li>
<li><strong>空间占用</strong>：ArrayList在创建时需要分配一段连续的内存空间，因此会占用较大的空间。LinkedList每个节点只需要存储元素和指针，因此相对较小。</li>
<li><strong>使用场景</strong>：ArrayList适用于频繁随机访问和尾部的插入删除操作，而LinkedList适用于频繁的中间插入删除操作和不需要随机访问的场景。</li>
<li><strong>线程安全</strong>：这两个集合都<strong>不是线程安全的</strong>，Vector是线程安全的</li>
</ul>
<h3 id="ArrayList变成线程安全的方式有："><a href="#ArrayList变成线程安全的方式有：" class="headerlink" title="ArrayList变成线程安全的方式有："></a>ArrayList变成线程安全的方式有：</h3><ul>
<li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Vector类代替ArrayList，Vector是线程安全的List实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>

<h3 id="为什么ArrayList不是线程安全的，具体来说是哪里不安全"><a href="#为什么ArrayList不是线程安全的，具体来说是哪里不安全" class="headerlink" title="为什么ArrayList不是线程安全的，具体来说是哪里不安全"></a>为什么ArrayList不是线程安全的，具体来说是哪里不安全</h3><p>在高并发添加数据下，ArrayList会暴露三个问题;</p>
<ul>
<li>部分值为null（我们并没有add null进去）</li>
<li>索引越界异常</li>
<li>size与我们add的数量不符</li>
</ul>
<p>为了知道这三种情况是怎么发生的，ArrayList，add 增加元素的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ensureCapacityInternal()这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足，如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容。</p>
<p>大体可以分为三步：</p>
<ul>
<li>判断数组需不需要扩容，如果需要的话，调用grow方法进行扩容；</li>
<li>将数组的size位置设置值（因为数组的下标是从0开始的）；</li>
<li>将当前集合的大小加1</li>
</ul>
<p>下面我们来分析三种情况都是如何产生的：</p>
<ul>
<li>部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。</li>
<li>索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；</li>
<li>size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的；</li>
</ul>
<h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：</p>
<ul>
<li>计算新的容量：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。</li>
<li>创建新的数组：根据计算得到的新容量，创建一个新的更大的数组。</li>
<li><strong>将元素复制：将原来数组中的元素逐个复制到新数组中。</strong></li>
<li><strong>更新引用：将ArrayList内部指向原数组的引用指向新数组</strong>。</li>
<li>完成扩容：扩容完成后，可以继续添加新元素。</li>
</ul>
<p>ArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。</p>
<p>之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新容量计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的-List，-CopyonWriteArraylist是如何实现线程安全的"><a href="#线程安全的-List，-CopyonWriteArraylist是如何实现线程安全的" class="headerlink" title="线程安全的 List， CopyonWriteArraylist是如何实现线程安全的"></a>线程安全的 List， CopyonWriteArraylist是如何实现线程安全的</h3><p>CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到当前List集合保存数据的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//将当前数组拷贝一份的同时，让其长度加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//替换引用，将数组的引用指向给新数组的地址</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到源码可以知道写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。</p>
<p>在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。</p>
<p>现在我们来看读操作，读是没有加锁的，所以读是一直都能读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419123807537.png" alt="image-20250419123807537"></p>
<p>常见的Map集合（非线程安全）：</p>
<ul>
<li><code>HashMap</code>是基于哈希表实现的<code>Map</code>，它根据键的哈希值来存储和获取键值对，JDK 1.8中是用数组+链表+红黑树来实现的。<code>HashMap</code>是非线程安全的，在多线程环境下，当多个线程同时对<code>HashMap</code>进行操作时，可能会导致数据不一致或出现死循环等问题。比如在扩容时，多个线程可能会同时修改哈希表的结构，从而破坏数据的完整性。</li>
<li><code>LinkedHashMap</code>继承自<code>HashMap</code>，它在<code>HashMap</code>的基础上，使用双向链表维护了键值对的插入顺序或访问顺序，使得迭代顺序与插入顺序或访问顺序一致。由于它继承自<code>HashMap</code>，在多线程并发访问时，同样会出现与<code>HashMap</code>类似的线程安全问题。</li>
<li><code>TreeMap</code>是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code>是非线程安全的，在多线程环境下，如果多个线程同时对<code>TreeMap</code>进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常。</li>
</ul>
<p>常见的Map集合（线程安全）：</p>
<ul>
<li><code>Hashtable</code>是早期 Java 提供的线程安全的<code>Map</code>实现，它的实现方式与<code>HashMap</code>类似，但在方法上使用了<code>synchronized</code>关键字来保证线程安全。通过在每个可能修改<code>Hashtable</code>状态的方法上加上<code>synchronized</code>关键字，使得在同一时刻，只能有一个线程能够访问<code>Hashtable</code>的这些方法，从而保证了线程安全。</li>
<li><code>ConcurrentHashMap</code>在 JDK 1.8 以前采用了分段锁等技术来提高并发性能。在<code>ConcurrentHashMap</code>中，将数据分成多个段（Segment），每个段都有自己的锁。在进行插入、删除等操作时，只需要获取相应段的锁，而不是整个<code>Map</code>的锁，这样可以允许多个线程同时访问不同的段，提高了并发访问的效率。在 JDK 1.8 以后是通过 volatile + CAS 或者 synchronized 来保证线程安全的。</li>
</ul>
<h3 id="如何对map进行快速遍历"><a href="#如何对map进行快速遍历" class="headerlink" title="如何对map进行快速遍历"></a>如何对map进行快速遍历</h3><ul>
<li>使用for-each循环和entrySet()方法：这是一种较为常见和简洁的遍历方式，它可以同时获取<code>Map</code>中的键和值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和entrySet()遍历Map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用for-each循环和keySet()方法：如果只需要遍历<code>Map</code>中的键，可以使用<code>keySet()</code>方法，这种方式相对简单，性能也较好。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和keySet()遍历Map的键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用迭代器：通过获取Map的entrySet()或keySet()的迭代器，也可以实现对Map的遍历，这种方式在需要删除元素等操作时比较有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历Map</span></span><br><span class="line">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Lambda 表达式和forEach()方法：在 Java 8 及以上版本中，可以使用 Lambda 表达式和<code>forEach()</code>方法来遍历<code>Map</code>，这种方式更加简洁和函数式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式和forEach()方法遍历Map</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Stream API：Java 8 引入的<code>Stream API</code>也可以用于遍历<code>Map</code>，可以将<code>Map</code>转换为流，然后进行各种操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream API遍历Map</span></span><br><span class="line">        map.entrySet().stream()</span><br><span class="line">          .forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">        Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">                                            .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">                                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">        System.out.println(filteredMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><p>在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了.</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419124312334.png" alt="image-20250419124312334"></p>
<p>所以在 <strong>JDK 1.8</strong> 版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419124327281.png" alt="image-20250419124327281"></p>
<h3 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h3><p>hashmap不是线程安全的，hashmap在多线程会存在下面的问题：</p>
<ul>
<li>JDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。</li>
<li>JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。</li>
</ul>
<p>如果要保证线程安全，可以通过这些方法来保证：</p>
<ul>
<li>多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li>
<li>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</li>
</ul>
<h3 id="hashmap的put过程"><a href="#hashmap的put过程" class="headerlink" title="hashmap的put过程"></a>hashmap的put过程</h3><p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419125219692.png" alt="image-20250419125219692"></p>
<p>HashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：</p>
<blockquote>
<p>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。</p>
</blockquote>
<blockquote>
<p>第二步：检查该位置是否为空（即没有键值对存在）</p>
</blockquote>
<ul>
<li>如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。</li>
</ul>
<blockquote>
<p>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</p>
</blockquote>
<ul>
<li>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</li>
</ul>
<blockquote>
<p>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：</p>
</blockquote>
<p>如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。</p>
<ul>
<li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li>
<li>如果没有找到相同的键，则将新的键值对添加到链表的头部。</li>
</ul>
<p>如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。</p>
<ul>
<li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li>
<li>如果没有找到相同的键，则将新的键值对添加到红黑树中。</li>
</ul>
<blockquote>
<p>第五步：检查链表长度是否达到阈值（默认为8）：</p>
</blockquote>
<ul>
<li>如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。</li>
</ul>
<blockquote>
<p>第六步：检查负载因子是否超过阈值（默认为0.75）：</p>
</blockquote>
<ul>
<li>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。</li>
</ul>
<blockquote>
<p>第七步：扩容操作：</p>
</blockquote>
<ul>
<li>创建一个新的两倍大小的数组。</li>
<li>将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。</li>
<li>更新HashMap的数组引用和阈值参数。</li>
</ul>
<blockquote>
<p>第八步：完成添加操作。</p>
</blockquote>
<p>此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="put-key-val-和get-key"><a href="#put-key-val-和get-key" class="headerlink" title="put(key,val)和get(key)"></a>put(key,val)和get(key)</h4><ul>
<li>存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。</li>
<li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用<strong>equals()方法</strong>(equals方法就是比较hash值是否在一致)确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li>
</ul>
<p>调用 get 方法有几点需要注意的地方：</p>
<ul>
<li><strong>空指针异常（NullPointerException）</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get</code> 方法，而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>），那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键。</li>
<li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 <code>get</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code>。</li>
</ul>
<h4 id="String适合做Key"><a href="#String适合做Key" class="headerlink" title="String适合做Key"></a>String适合做Key</h4><p>用 string 做 key，因为 String对象是不可变的，一旦创建就不能被修改，这确保了Key的稳定性。如果Key是可变的，可能会导致hashCode和equals方法的不一致，进而影响HashMap的正确性。</p>
<h4 id="HashMap要用红黑树而不是平衡二叉树"><a href="#HashMap要用红黑树而不是平衡二叉树" class="headerlink" title="HashMap要用红黑树而不是平衡二叉树"></a>HashMap要用红黑树而不是平衡二叉树</h4><ul>
<li>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li>
<li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因。</li>
</ul>
<h4 id="hashmap-key可以为null吗？"><a href="#hashmap-key可以为null吗？" class="headerlink" title="hashmap key可以为null吗？"></a>hashmap key可以为null吗？</h4><p>可以为 null。</p>
<ul>
<li><p>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</p>
</li>
<li><p>hashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；</p>
</li>
<li><p>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个。</p>
</li>
</ul>
<h4 id="多线程下可能会出现的问题"><a href="#多线程下可能会出现的问题" class="headerlink" title="多线程下可能会出现的问题"></a>多线程下可能会出现的问题</h4><ul>
<li>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>
<li>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>
</ul>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：</p>
<ul>
<li><strong>第1步</strong>是对哈希表长度的扩展（2倍）</li>
<li><strong>第2步</strong>是将旧哈希表中的数据放到新的哈希表中。</li>
</ul>
<p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong></p>
<p>如我们从16扩展为32时，具体的变化如下所示：</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419125815050.png" alt="image-20250419125815050"></p>
<p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419125859493.png" alt="image-20250419125859493"></p>
<p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419125938150.png" alt="image-20250419125938150"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>
<h3 id="ConcurrentHashMap怎么实现的"><a href="#ConcurrentHashMap怎么实现的" class="headerlink" title="ConcurrentHashMap怎么实现的"></a>ConcurrentHashMap怎么实现的</h3><blockquote>
<p>JDK 1.7 ConcurrentHashMap</p>
</blockquote>
<p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419130028980.png" alt="image-20250419130028980"></p>
<p>JDK 1.7 ConcurrentHashMap 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>
<blockquote>
<p>JDK 1.8 ConcurrentHashMap</p>
</blockquote>
<p>在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表，而 JDK 1.8 则使用了数组 + 链表&#x2F;红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：</p>
<p><img src="/2025/04/21/%E9%9D%A2%E8%AF%95/image-20250419130036106.png" alt="image-20250419130036106"></p>
<p>JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：</p>
<ul>
<li>如果为空则使用 volatile 加 CAS 来初始化</li>
<li>如果容器不为空，则根据存储的元素计算该位置是否为空。<ul>
<li>如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；</li>
<li>如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li>
</ul>
</li>
</ul>
<p>如果把上面的执行用一句话归纳的话，<strong>就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了</strong>。</p>
<p>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。</p>
<h4 id="分段锁是可重入的吗？"><a href="#分段锁是可重入的吗？" class="headerlink" title="分段锁是可重入的吗？"></a>分段锁是可重入的吗？</h4><p>JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</p>
<h4 id="已经用了synchronized，为什么还要用CAS呢"><a href="#已经用了synchronized，为什么还要用CAS呢" class="headerlink" title="已经用了synchronized，为什么还要用CAS呢"></a>已经用了synchronized，为什么还要用CAS呢</h4><p><strong>CAS</strong>:CAS是一种<strong>无锁</strong>的原子操作，它包含三个操作数：内存位置(V)、预期原值(A)和新值(B)。当且仅当V的值等于A时，CAS才会将V的值更新为B，否则不做任何操作。</p>
<p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。</p>
<p>比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</p>
<p>当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</p>
<h4 id="ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="ConcurrentHashMap用了悲观锁还是乐观锁?"></a>ConcurrentHashMap用了悲观锁还是乐观锁?</h4><p>悲观锁和乐观锁都有用到。</p>
<p>添加元素时首先会判断容器是否为空：</p>
<ul>
<li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li>
<li>如果容器不为空，则根据存储的元素计算该位置是否为空。</li>
<li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li>
<li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set集合有什么特点？如何实现key无重复的？"><a href="#Set集合有什么特点？如何实现key无重复的？" class="headerlink" title="Set集合有什么特点？如何实现key无重复的？"></a>Set集合有什么特点？如何实现key无重复的？</h3><ul>
<li><strong>set集合特点</strong>：Set集合中的元素是唯一的，不会出现重复的元素。</li>
<li><strong>set实现原理</strong>：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。当向Set集合中插入元素时，会先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素，如果存在则不会再次插入，保证了元素的唯一性。</li>
</ul>
<h3 id="有序的Set是什么？记录插入顺序的集合是什么？"><a href="#有序的Set是什么？记录插入顺序的集合是什么？" class="headerlink" title="有序的Set是什么？记录插入顺序的集合是什么？"></a>有序的Set是什么？记录插入顺序的集合是什么？</h3><ul>
<li><strong>有序的 Set 是TreeSet和LinkedHashSet</strong>。TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序</li>
<li><strong>记录插入顺序的集合通常指的是LinkedHashSet</strong>，它不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。</li>
</ul>
<h1 id="三、java并发"><a href="#三、java并发" class="headerlink" title="三、java并发"></a>三、java并发</h1><h1 id="四、体系化八股"><a href="#四、体系化八股" class="headerlink" title="四、体系化八股"></a>四、体系化八股</h1><h2 id="如何保证MQ的可靠性"><a href="#如何保证MQ的可靠性" class="headerlink" title="如何保证MQ的可靠性"></a>如何保证MQ的可靠性</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis-分布式锁的原子性保障"><a href="#Redis-分布式锁的原子性保障" class="headerlink" title="Redis 分布式锁的原子性保障"></a><strong>Redis 分布式锁的原子性保障</strong></h3><ul>
<li><strong>SET NX 命令</strong>：一个线程拿到锁，另一个线程拿不到锁就不能往下走，这是锁的互斥性。通过 <code>SET key value NX EX expire</code> 实现原子性加锁（只有 key 不存在时才设置），单命令天然<strong>原子性</strong>。</li>
<li><strong>LUA 脚本</strong>：<strong>多步骤操作</strong>（如加锁+续期）需用 Lua 脚本保证原子性，避免命令间穿插导致的数据不一致。</li>
</ul>
<h3 id="2-锁的自动释放与看门狗机制"><a href="#2-锁的自动释放与看门狗机制" class="headerlink" title="2. 锁的自动释放与看门狗机制"></a><strong>2. 锁的自动释放与看门狗机制</strong></h3><ul>
<li><strong>过期时间</strong>：锁必须设置过期时间，防止业务异常导致死锁。</li>
<li><strong>看门狗（Watchdog）</strong>：业务执行期间定时续期锁（如每 10s 延长过期时间），避免锁提前失效。</li>
<li><strong>守护线程</strong>：看门狗设为守护线程，业务线程挂掉时JVM自动终止守护线程，防止锁永久占用。</li>
</ul>
<h3 id="3-可重入锁的设计"><a href="#3-可重入锁的设计" class="headerlink" title="3. 可重入锁的设计"></a><strong>3. 可重入锁的设计</strong></h3><ul>
<li><strong>Java的计数器机制：</strong></li>
<li><code>synchronized</code> 可重入性通过 <strong>对象头（Mark Word）</strong> 和 <strong>锁计数器</strong> 实现。</li>
<li>AQS 通过 <strong>状态变量（state）</strong> 和 <strong>当前持有线程</strong> 实现可重入性。</li>
<li><strong>Redission的计数器机制</strong>：同一线程多次获取锁时，用 Redis 哈希结构（如 <code>HINCRBY</code>）<strong>要锁的东西为KEY</strong>，**线程id+UUID为FIELD，重入次数为VALUE，**记录重入次数，解锁时递减计数器，归零后释放锁t。</li>
<li><strong>线程唯一标识</strong>：结合线程 ID + UUID 作为哈希字段，底层Hse，避免多线程冲突。</li>
</ul>
<h3 id="4-可重入锁阻塞的实现"><a href="#4-可重入锁阻塞的实现" class="headerlink" title="4. 可重入锁阻塞的实现"></a><strong>4. 可重入锁阻塞的实现</strong></h3><ul>
<li><strong>Java的方案自旋重试</strong>：未抢到锁的线程循环尝试加锁（如 <code>while (true)</code>），直到成功或超时。</li>
<li>synchronized</li>
<li><strong>轻量级锁阶段</strong>：线程在用户态通过 CAS 自旋短暂尝试获取锁，避免频繁切换到内核态。自旋次数由 JVM 自适应调整，若自旋失败则锁升级为重量级锁。</li>
<li><strong>重量级锁阶段</strong>：未抢到锁的线程被放入 ObjectMonitor 的 _EntryList 队列，进入内核态阻塞。锁释放时，JVM 从队列中唤醒线程，但不保证唤醒顺序，允许新来的线程直接抢锁，体现非公平性。</li>
<li>AQS</li>
<li>自旋 + 阻塞” 的混合策略。</li>
<li><strong>Redission的方案订阅发布机制</strong>：</li>
<li>如果线程未获取到锁，Redisson 会通过 Redis 的 <code>Pub/Sub</code> 订阅锁的释放事件。</li>
<li>当锁被释放时（即其他线程释放锁），Redisson 会收到发布的通知。</li>
<li>收到通知后，Redisson 会再次尝试获取锁。</li>
<li>这种机制避免了传统自旋锁的高 CPU 消耗，同时提供了较高的性能和实时性</li>
</ul>
<h3 id="5-主从架构下的锁丢失问题"><a href="#5-主从架构下的锁丢失问题" class="headerlink" title="5. 主从架构下的锁丢失问题"></a><strong>5. 主从架构下的锁丢失问题</strong></h3><ul>
<li><strong>主从同步延迟</strong>：主节点写入锁后宕机，一个从节点转从为主，但从节点未同步导致新主节点无锁数据，其他线程可能重复加锁。</li>
<li><strong>解决方案</strong>：部署多主集群（如 Redis Cluster），加锁需所有主节点成功；或采用 RedLock 算法（半数以上节点成功）。</li>
</ul>
<h3 id="6-RedLock-算法的优缺点"><a href="#6-RedLock-算法的优缺点" class="headerlink" title="6. RedLock 算法的优缺点"></a><strong>6. RedLock 算法的优缺点</strong></h3><p>要求REDIS要部署多个主节点,但是只需要半数以上加锁成功就行了,当某个线程加锁半数以上的节点成功了,那么其他线程就不可能再做到半数以上,加锁成功了,这就满足了互斥项</p>
<ul>
<li><strong>优点</strong>：通过多个独立 Redis 节点实现跨节点锁，容忍单点故障。</li>
<li><strong>缺点：</strong></li>
<li>需严格时钟同步（否则可能误判锁有效性）。</li>
<li>Java 的 Stop-The-World GC 可能导致看门狗失效。</li>
<li>实现复杂，运维成本高，实际应用较少。</li>
</ul>
<h3 id="7-Redisson-的优化方案"><a href="#7-Redisson-的优化方案" class="headerlink" title="7. Redisson 的优化方案"></a><strong>7. Redisson 的优化方案</strong></h3><ul>
<li><strong>底层实现</strong>：基于 Redis 哈希结构（非单纯 <code>SET NX</code>），支持可重入、公平锁等高级特性。</li>
<li><strong>多主集群</strong>：通过 Redis Cluster 部署，结合 RedLock 算法提升可靠性。</li>
</ul>
<h3 id="8-锁的设计原则"><a href="#8-锁的设计原则" class="headerlink" title="8. 锁的设计原则"></a><strong>8. 锁的设计原则</strong></h3><ul>
<li><strong>互斥性</strong>：同一时间仅一个客户端能持有锁。</li>
<li><strong>无饥饿</strong>：避免线程无限等待（如设置超时时间）。</li>
<li><strong>容错性</strong>：主从&#x2F;多节点故障时仍能保证锁的有效性。</li>
</ul>
<h3 id="9-常见陷阱"><a href="#9-常见陷阱" class="headerlink" title="9. 常见陷阱"></a><strong>9. 常见陷阱</strong></h3><ul>
<li><strong>线程 ID 冲突</strong>：集群环境下线程 ID 可能重复，需拼接 UUID 保证唯一性。</li>
<li><strong>GC 暂停风险</strong>：JVM 的 Stop-The-World GC 可能导致看门狗失效，GC会暂停线程,导致看门狗无法对锁进行续期,然后锁就过期了</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Redis 分布式锁的核心是<strong>原子性 + 自动释放 + 容错机制</strong>，但实现细节需考虑主从同步、时钟偏差、GC 等复杂场景。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>要讲明白SYCHRONIZED的你首先得从计算机的发展史说起CPU的速度非常快但是内存的速度比较慢 为了缓解CPU和内存速度不一致的问题 就有了三级缓存 一级和二级缓存呢是CPU核心私有的 但是第三级缓存是共享的</p>
<p>那么问题来了在多线程并发的环境下当某一个CPU核心去执行某个线程任务时把内存中的数据读到缓存中然后呢修改了缓存中的数据当缓存数据还没有同步到主存时那线程B从主存中读数据那读的不就是旧数据了吗</p>
<p>一个线程修改了共享数据但是另外一个线程无法立刻获取到最新的共享数据这就是可见性问题，除此之外执行代码的时候CPU或者编译器可能会对指令进行重排序导致执行顺序和代码书写顺序不一致这就是有序性问题，</p>
<h3 id="synchronized的是什么能解决什么问题"><a href="#synchronized的是什么能解决什么问题" class="headerlink" title="synchronized的是什么能解决什么问题"></a>synchronized的是什么能解决什么问题</h3><p>synchronized它就是个锁,能保证某一段代码,同一时间只能被拿到锁的线程访问这就是保证了原子性,synchronize的编译之后,就是monitor inter和monitor exit两个指令,monitor inter就是加锁,加锁的时候会使用读屏障,强行去从储存重新读取数据,也就是说它能保证读到的数据都是最新的,然后monitor exit是什么它是就是解锁,解锁的时候,通过写屏障保证，强制将CPU缓存中的变量刷新到主存中，能够保证线程修改后的数据，对其他线程立刻可见，这就是保证了可见性SYCHONNET呢能够通过内存屏障防止指令重排，这就是有序性</p>
<h3 id="那synchronized怎么用呢"><a href="#那synchronized怎么用呢" class="headerlink" title="那synchronized怎么用呢"></a>那synchronized怎么用呢</h3><p>它修饰普通方法锁的就是this，就是当前对象，</p>
<p>一个对象用一把锁修饰静态方法，锁的是类点class对象，也就是类的所有对象共用一把锁</p>
<p>修饰代码块那你括号里写什么它就锁什么</p>
<h3 id="synchronized的在JDK1-6有优化做到锁升级"><a href="#synchronized的在JDK1-6有优化做到锁升级" class="headerlink" title="synchronized的在JDK1.6有优化做到锁升级"></a>synchronized的在JDK1.6有优化做到锁升级</h3><p>那为什么要做锁升级呢肯定是因为不做所升级它就慢</p>
<p>synchronized说到根上，他加锁还是要调用操作系统底层原语MUTX，然后又涉及到线程的阻塞与唤醒，那java线程的模型呢是一对一的，每一个java线程都直接对应一个操作系统的内核级线程，每次切换线程都需要操作系统从用户态切换到内核态，开销很大，这也就是之前synchronized的问题所在</p>
<p><strong>优化：</strong></p>
<p>那你既然线程阻塞唤醒它比较慢，那在低并发的情况下，锁竞争比较少的情况下，我就不让你阻塞，只要你不阻塞操作系统，就不需要从用户态切换到内核态就减少了开销，就提高了性能，并发量比较高，所竞争比较激烈的时候，我再让你去阻塞，这就有了所升级的过程，从无锁到偏向锁到轻量级锁到重量级锁</p>
<p>为什么要做锁升级</p>
<p>事实上，一个系统大多数的时候都是不存在所竞争的，经常就只有一两个线程去拿锁，比如说一个商城系统24小时运行吗，从凌晨一点到早上六点没几个人，所以几乎没有所竞争，高并发的时候往往发生在一些固定的时间点，比如周末，其他时间并发量都不大，所以一般都没啥高并发量，即使是高并发系统，也不是时时刻刻都有高并发，大多数时间还是只有一个或者几个线程在枪锁，为了在低并发的时候降低获取锁的代价，为了提高低并发时候的性能，所以就做了锁升级</p>
<p>锁升级过程</p>
<p>其实是应对越来越激烈的锁竞争的过程。最开始我们的系统是无锁状态，当有第一个线程来访问同步代码块时，JVM将对象头的Mark word锁标志位设置为偏向锁，然后将线程id记录到那个Mark word里面，这个时候这个线程进入这个同步代码块，就不需要其他的同步操作了，非常的轻非常的快。偏向锁考虑的是那种只有一个线程抢锁的场景，那什么时候升级到轻量级锁呢。当第二个线程来抢锁就升级为轻量级锁，第二个线程拿不到锁，就采用cs加自旋的方式，不断重新尝试获取锁，轻量级所考虑的是竞争所的线程不多，而且线程持有所的时间也不长的一个情景，因为阻塞线程需要操作系统，从用户态切换到内核态，代价比较大，如果刚刚才走过了这个线程，然后这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆我不阻塞这个线程了，让它自旋等待所释放，这样就避免了线程上下文的一个开销，操作系统就不需要切换内核态，短时间的自选性能是不错的，但长时间的自旋会让cpu一直在转，浪费cpu，自旋的时间有上一个线程自旋时间决定，可以看到偏向锁只记录线程id，轻量锁只是自旋枪锁，整个过程在用户态即可完成，不需要切换内核态，这个设计也就提高了性能。当第二个线程自旋到一定次数之后还是没拿到锁，获取锁失败了或者当有更多的线程来抢锁了那就升级为重量级锁重量级锁，加锁就需要调用操作系统的底层原语music，所以每次切换线程都需要操作系统切换到内核态开销很大，把那些没拿到锁的线程都给阻塞住。当升级到重量级锁的时候对象头的Mark word的指针就会指向锁监视器monitor，那为什么要有锁监视器呢，锁监视器主要是用来负责记录锁的拥有者，记录锁的重入次数，负责线程的阻塞唤醒。锁监视器就是一个对象，首先是owner用来保存持有锁的线程，然后重入次数的一个计数器，用来计入锁的一个重入次数，然后还有锁池和等待池，锁池只要用来管理抢锁失败的线程，等待时主要用来管理调用位的方法，陷入等待状态的一个线程，那重入次数计数器是干嘛的呢，当一个线程重复的去获取这个锁，这就是可重入锁</p>
<p>那synchronized的可重入怎么实现呢</p>
<p>就是依赖锁监视器这种这个重复次数的计数器重复一次计数器加一次释放一次计数器减一次减到零就完全释放锁了</p>
<p>那锁持和等待值是干嘛的呢, 首先在重量级锁状态, 当有线程拿到锁, 此时监视器的owner字段就记录拿到锁的线程, 没有拿到锁的线程就被阻塞住, 进入blocking状态, 然后呢放到锁池中, 当拿到锁的线程调用了wait方法, 那该线程就释放锁, 然后进入waiting状态, 然后被放到等待池当中, 当某个线程调用了notify, 唤醒了这个waiting的线程, 那这个线程就从waiting的状态变成blocking状态, 然后再被放入到锁池中, 等待锁释放, 重新去抢锁, 这就是锁持和等待时的作用, 锁竞争失败的线程和调用了wait方法的线程, 有什么本质区别吗, 这不都是在阻塞等待吗, 为什么要放在锁持和等待池, 这两个完全不同的集合中呢, 首先所持放的是竞争所失败的线程, 线程状态是blocking, 竞争所失败, 那他的目标就是要尽快获取所去执行任务, 这是锁的互斥问题, 等待时放的是主动放弃锁的线程, 我主动放弃了锁, 我暂时还不想要锁这个线程, 等待被其他线程唤醒之后, 去配合其他线程去完成某项任务, 的线程状态是waiting或者time waiting, 这些微型状态的线程是想等某个资源到位了, 等某个事情完成了, 然后再被notify唤醒, 然后放入锁池中, 准备去抢所做业务, 这是线程通信问题, 所以等待池的线程和锁持的线程, 它的目标和要解决的问题完全不一样, 当然要放到两个不同的集合了</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>简历一写就是秒杀项目, 什么高并发高可用, 面试一问, 悲观锁和乐观锁是啥, 你绞尽脑汁想了半天就蹦出几个词, 什么枷锁, 什么cs, 什么自旋, 问你cs怎么实现的, 你支支吾吾半天也说不出来, 问你cs自选性能问题怎么解决, 你磕磕巴巴半天还是说不出来, 问你cs真的无锁吗, 你居然问我啥叫无锁, 这就是你简历上写的精通java, 精通高并发, 精通JUC, 回答我，那啥叫悲观锁呀, 悲观锁就是悲观的认为, 如果不严格加锁, 那么多线程执行一定会出问题, 所以每次访问公共资源都得加锁, 线程必须获得锁之后才能正常执行, 否则就阻塞等待, 悲观锁确实好使呀, 但他也确实慢, 为什么慢, 如果说程序中存在大量的读操作, 那么其实没有必要每次读的时候都加速, 或者说同步代码块执行的时间非常短, 它远小于线程阻塞切换的那个时间, 那你这时候加锁得不偿失呀, 那有没有一种方法可以不加锁, 就对多线程访问共享资源做出限制呢, 有就是乐观锁, CAS就是乐观锁的一个经典实现, 简单讲一下, cs就是女神的门口有个牌子, 牌子是零的话, 就代表空闲牌子是一的话, 就代表米神比较繁忙, 这个时候ab两个线程看到门上的牌子是零, A1路快跑过去, 把牌子上的零改成了一, 然后A就进女神房间去做一些羞羞的事情了, 当B走到门口一看牌子是一不是零, 那B就进不去了, 对应到代码里, 女神就是那个共享资源, 牌子上的这个值就是一个状态值, 线程A和B看到牌子上是零, 那么零就是O的value, 一就是new value, 两个线程想要访问共享资源, 就需要争着把状态值改为new value, 当线程A呢拿到CPU的时间片, 对比了一下门口的牌子为零, 等于old value, 没毛病, 就将其改为一线程A就进入女神房间了, 就能访问共享资源了, 这就是cs compare and sop compare, 对比, 对比牌子上的值和自己, 第一次看到old value是否一致一致, 就将牌子上的值和自己的new value交换线程B来, 对比的时候, 发现它的old value是零, 但是牌子上的已经是一了不一致了, 这说明已经有线程去访问共享资源了, 那这个时候线程B进不去咋办呢, 可以自选等待, 不断尝试用cs进行修改, 直到县城B耐心耗尽为止, 他沉默离场, 所以乐观所就是, 当县城想要访问共享资源的时候, 总是乐观的认为没有人和他竞争, 所以不会加速, 只是比较状态值是否等于他的预期值相等, 说明真的没有被其他线程修改, 然后修改状态值并访问共享资源, 所以乐观锁的本质其实是不加锁, 那不知道有没有发现一个问题啊, Compare and swap, 先比较再交换, 这是两步操作, 那两步操作你就得保证原子性啊, 那么问题来了, 怎么保证这两步操作原子性有大聪明就要说了, 保证原子性, 你加锁就行了, 咱就是说有没有一种可能啊, CAS就是为了在不加锁的情况下保证并发安全, 为了不加锁, 得先加把锁, 这不扯淡呢, 那怎么办呢, 在java中, 你要直接使用cs, 需要调用unsafe类的那compare and soft int, 或者compare and sob long, 或者compare and so object等等方法, 这些方法都是由native修饰的, 本地方法, 也就是说是C加加实现的, 但是你即便用C加加代码写, 那比较交换也是两步操作, 那C加加也没有办法保证原子性啊, 怎么办, 这里的C加加本地方法中呢, 其实依赖了CPU的原子指令, 比如说在X86架构下, 指令是compare and exchange, 这个指令是由硬件直接支持, 确保原子性的, 那硬件是咋做的呢, 其实是执行的时候通过锁定总线, 避免其他CPU访问共享资源, 或者说锁定缓存行来实现的, 万万没想到啊, 一个简单的cas操作软件居然是无法实现的, 最终还是要依赖硬件来实现, 那cas真的无锁吗, 从硬件上来看, 锁定总线或者锁定缓存行的操作, 其实就是硬件锁, 看看这里锁定总线的操作, 想一想之前的那个悲观锁的概念, 是不是硬件层面, 他悲观地认为, 不锁定总线就会出现线程安全问题, 所以做了锁定总线的操作呢, 所以从硬件上来看, cs其实还是加锁的悲观锁, 但是硬件的操作性能很高啊, 代价很低, 而且不阻塞线程, 从软件层面来看, 他没有用操作系统的music言语, 避免了软件层面的所竞争和线程阻塞问题, 所以从软软件层面上来说, 它就是无锁的, 当你了解了C, 你就自然而然的了解了, atomic integer是怎么实现的, atomic integer无非就是有一个volatile, 修饰的一个int变量, 然后每次需要自增或者修改的时候, 要利用cs去修改这个int变量就可以了, VOLUNTILE保证可见性, cs保证原子性, 那atomic long其实你也知道怎么实现了, 无非就是换了个long类型的变量呗, 这都很好理解, 因为都是数字呀, cs比较交换一个数字, 这很正常, 那么问题来了, atomic reference它能保证原子的去修改一个对象, 它是怎么实现的, atomic reference它比较交换, 比较的是对象的地址, 刚聊的是java代码层面的乐观所, 数据库操作层面也可以采用cs的思想, 实现一个乐观锁, 比如说库存场景update某张表, set库存等于新值, where库存等于旧值, 当库存等于之前的旧值的时候, 才能修改为新值, 这就是cs除了库存, 比较更常用的, 其实是给表里增加一个版本号字段, 然后进行对比, 那么问题来了, 怎么保证原子性, 单条circle的原子性是由数据库直接保证的, 所以你不需要考虑再来思考这个问题, 用circle写的cs操作真的无锁吗, 从数据库的层面来看, 执行update语句需要加行锁或者表锁, 那以加行锁为例, 为什么加行锁啊, 因为数据库悲观的认为, 不加行锁就会出现并发安全问题, 所以从数据库底层来看, 还是加锁了悲观锁, 但是从上层的circle来看, 没加锁, 有些同学可能在想, 这都给我搞糊涂了, 到底加没加锁啊, cs啊, 其实乐观还是悲观, 枷锁还是无锁, 从不同的角度, 不同的层级来看就是不一样的, 对我们写业务代码这种偏上层的开发来说, cs就是无锁的, 但是从底层的视角来看, 就未必是无锁了, 你也不用纠结cs是否真的无锁, 你只需要知道它性能很好就可以了, 那cs就没啥问题了吗, 那肯定是有的呀, cs会产生一个经典问题, 就是ABA当线程一读取一个值为A, 想修改为C, 但是线程二拿到时间片之后, 把值从A修改为B, 然后又修改为A, 那当线链拿到时间片执行cs操作的时候, 发现还是A啊, 以为没有被修改过, 其实已经被修改过了, 这就是ABA问题, 回到之前的库存场景, 第一个线程读取库存为一, 然后第二个线程扣减了库存, 然后又退货了, 给库存再加一, 然后第一个线程拿到时间片之后, 发现库存还是一继续操作, 这种情况下, ABA问题其实不需要解决, 再来看另外一种情况, 线程一读取栈顶元素为A, 然后呢线程二做了两次出站操作, 线程1cs1对比, 占领原子还是A这个时候线程一将A修改为B, 修改的那个A还是曾经读取的那个A了吗, 并不是, 所以这里就很容易出问题, 这俩是不同的元素, 所以cs问题在哪, 它只进行值的比较值相同, 但是未必就是一个数据啊, 怎么解决呢, 一般会使用这个版本号, 版本号一直递增, 那把值对比改为版本号的对比就可以了, 这也是atomic staff reference的原理, 那cs还有没有其他的问题, cs操作往往是配合自旋一块用的, 当线程cs操作失败了, 就不断的自旋重试, 那如果长时间的不成功, 就很浪费CPU, 那这个问题怎么解决呢, 上一期聊到synchronized的轻量级锁, 就是cs加自旋自旋的时间长了, 或者线程竞争大了, 就会浪费CPU, 然后升级为重量级锁, SYNCHIZED的重量级锁, 通过操作系统的music言语加上锁监视器的锁持啊, 对象池啊去实现了一套线程阻塞唤醒的机制, 来避免长时间自旋导致CPU性能问题, 那下一期就聊一聊, AQS是如何不借助操作系统的music, 来解决这个问题的, 当然了, 这也是range lock, come on lasayle berry的原理</p>
<h1 id="深入理解悲观锁与乐观锁：从概念到实现"><a href="#深入理解悲观锁与乐观锁：从概念到实现" class="headerlink" title="深入理解悲观锁与乐观锁：从概念到实现"></a>深入理解悲观锁与乐观锁：从概念到实现</h1><p>在 Java 并发编程中，悲观锁和乐观锁是保证线程安全的两种重要机制。很多开发者在简历上写着 “精通高并发”“精通 JUC”，但面对基础的锁概念却含糊其辞。本文将从概念出发，深入解析悲观锁、乐观锁以及 CAS 机制的实现原理，帮你理清其中的逻辑。</p>
<h2 id="一、悲观锁：谨慎的并发控制方式"><a href="#一、悲观锁：谨慎的并发控制方式" class="headerlink" title="一、悲观锁：谨慎的并发控制方式"></a>一、悲观锁：谨慎的并发控制方式</h2><p>悲观锁的核心思想是<strong>悲观地认为多线程执行时一定会出现问题</strong>。它认为如果不严格加锁，多个线程访问公共资源时就会发生数据不一致等问题。所以，每次线程访问公共资源前必须先获得锁，只有拿到锁后才能正常执行，否则就会阻塞等待。</p>
<p>不过，悲观锁虽然能保证并发安全，但性能方面存在短板。这主要是因为：</p>
<ul>
<li><p>当程序中存在大量读操作时，其实没必要每次读都加锁，加锁会额外增加开销。</p>
</li>
<li><p>如果同步代码块执行时间很短，远小于线程阻塞切换的时间，此时加锁就得不偿失了。</p>
</li>
</ul>
<h2 id="二、乐观锁：乐观的无锁并发思路"><a href="#二、乐观锁：乐观的无锁并发思路" class="headerlink" title="二、乐观锁：乐观的无锁并发思路"></a>二、乐观锁：乐观的无锁并发思路</h2><p>为了解决悲观锁在某些场景下的性能问题，乐观锁应运而生。乐观锁的核心思路是<strong>线程访问共享资源时，总是乐观地认为没有其他线程与它竞争</strong>，所以不会提前加锁，而是通过比较状态值来判断是否可以访问资源。</p>
<h3 id="（一）CAS：乐观锁的经典实现"><a href="#（一）CAS：乐观锁的经典实现" class="headerlink" title="（一）CAS：乐观锁的经典实现"></a>（一）CAS：乐观锁的经典实现</h3><p>CAS（Compare and Swap，比较并交换）是乐观锁的经典实现。简单来说，它的工作过程就像这样：</p>
<ul>
<li><p>共享资源就像 “女神的房间”，门口有个 “牌子”（状态值），牌子为 0 代表空闲，为 1 代表繁忙。</p>
</li>
<li><p>线程 A 和 B 看到牌子是 0（预期的旧值，old value），都想进入房间。</p>
</li>
<li><p>线程 A 先拿到 CPU 时间片，对比发现牌子值和预期的旧值一致，就将牌子改为 1（新值，new value），然后进入房间访问资源。</p>
</li>
<li><p>线程 B 过来时，发现牌子值已经是 1，和自己预期的旧值 0 不一致，说明已有线程在访问资源。这时线程 B 可以选择自旋等待，不断尝试用 CAS 修改状态值，直到尝试次数耗尽后离场。</p>
</li>
</ul>
<p>所以，乐观锁的本质其实是不加锁，通过比较状态值来判断是否可以访问共享资源。</p>
<h2 id="三、CAS-的原子性保证：从软件到硬件"><a href="#三、CAS-的原子性保证：从软件到硬件" class="headerlink" title="三、CAS 的原子性保证：从软件到硬件"></a>三、CAS 的原子性保证：从软件到硬件</h2><p>CAS 操作分为 “比较” 和 “交换” 两步，这两步操作必须保证原子性，否则就会出现并发问题。那它是如何保证原子性的呢？</p>
<h3 id="（一）Java-中的-CAS-实现"><a href="#（一）Java-中的-CAS-实现" class="headerlink" title="（一）Java 中的 CAS 实现"></a>（一）Java 中的 CAS 实现</h3><p>在 Java 中，使用 CAS 需要调用Unsafe类的compareAndSwapInt、compareAndSwapLong、compareAndSwapObject等本地方法（由native修饰），这些方法由 C++ 实现。但即使是 C++ 代码，“比较” 和 “交换” 也是两步操作，同样面临原子性问题。</p>
<h3 id="（二）依赖-CPU-原子指令"><a href="#（二）依赖-CPU-原子指令" class="headerlink" title="（二）依赖 CPU 原子指令"></a>（二）依赖 CPU 原子指令</h3><p>C++ 本地方法最终依赖于 CPU 的原子指令来保证原子性。例如，在 X86 架构下，对应的指令是compare and exchange，这个指令由硬件直接支持，能确保原子性。</p>
<p>硬件实现原子性的方式有两种：</p>
<ul>
<li><p>锁定总线，避免其他 CPU 访问共享资源。</p>
</li>
<li><p>锁定缓存行，防止其他线程修改共享资源。</p>
</li>
</ul>
<p>没想到吧，一个简单的 CAS 操作，软件层面无法实现原子性，最终还是要依赖硬件。</p>
<h2 id="四、CAS-是无锁的吗？不同层面的不同答案"><a href="#四、CAS-是无锁的吗？不同层面的不同答案" class="headerlink" title="四、CAS 是无锁的吗？不同层面的不同答案"></a>四、CAS 是无锁的吗？不同层面的不同答案</h2><p>从不同角度看，CAS 是否 “无锁” 有不同的答案：</p>
<ul>
<li><p>从硬件层面来看，锁定总线或缓存行的操作其实是硬件锁。硬件悲观地认为不锁定就会出现线程安全问题，所以进行了锁定操作，从这个角度说 CAS 是加锁的。</p>
</li>
<li><p>从软件层面来看，CAS 没有使用操作系统的互斥锁，避免了软件层面的锁竞争和线程阻塞，所以可以认为它是无锁的。</p>
</li>
</ul>
<h2 id="五、基于-CAS-的原子类：AtomicInteger、AtomicLong、AtomicReference"><a href="#五、基于-CAS-的原子类：AtomicInteger、AtomicLong、AtomicReference" class="headerlink" title="五、基于 CAS 的原子类：AtomicInteger、AtomicLong、AtomicReference"></a>五、基于 CAS 的原子类：AtomicInteger、AtomicLong、AtomicReference</h2><p>了解了 CAS 的原理，就很容易理解 Java 中的原子类实现：</p>
<ul>
<li><p>AtomicInteger：内部有一个被volatile修饰的int变量，volatile保证可见性。每次自增或修改时，利用 CAS 来修改这个int变量，保证原子性。</p>
</li>
<li><p>AtomicLong：和AtomicInteger类似，只是变量类型为long。</p>
</li>
<li><p>AtomicReference：它通过比较和交换对象的地址来保证原子性地修改对象。</p>
</li>
</ul>
<h2 id="六、数据库层面的乐观锁：基于-CAS-思想"><a href="#六、数据库层面的乐观锁：基于-CAS-思想" class="headerlink" title="六、数据库层面的乐观锁：基于 CAS 思想"></a>六、数据库层面的乐观锁：基于 CAS 思想</h2><p>不仅 Java 代码中可以使用乐观锁，数据库操作也能采用 CAS 思想实现乐观锁。</p>
<h3 id="（一）库存场景的实现"><a href="#（一）库存场景的实现" class="headerlink" title="（一）库存场景的实现"></a>（一）库存场景的实现</h3><p>在库存场景中，可以这样写 SQL：update 表名 set 库存&#x3D;新值 where 库存&#x3D;旧值。只有当库存等于之前的旧值时，才能修改为新值，这就是 CAS 思想的体现。</p>
<h3 id="（二）版本号机制"><a href="#（二）版本号机制" class="headerlink" title="（二）版本号机制"></a>（二）版本号机制</h3><p>更常用的是给表增加一个版本号字段，修改时对比版本号。例如：update 表名 set 字段&#x3D;新值, 版本号&#x3D;版本号+1 where 版本号&#x3D;旧版本号。</p>
<p>数据库能保证单条 SQL 的原子性，所以不需要额外考虑原子性问题。但从数据库底层来看，执行update语句可能会加行锁或表锁（比如行锁），数据库悲观地认为不加锁会有并发安全问题，所以从底层看还是加了锁，只是上层 SQL 层面没显式加锁。</p>
<h2 id="七、CAS-的问题及解决"><a href="#七、CAS-的问题及解决" class="headerlink" title="七、CAS 的问题及解决"></a>七、CAS 的问题及解决</h2><h3 id="（一）ABA-问题"><a href="#（一）ABA-问题" class="headerlink" title="（一）ABA 问题"></a>（一）ABA 问题</h3><p>当线程 A 读取值为 A，想修改为 C 时，线程 B 先把 A 改为 B，再改回 A。此时线程 A 用 CAS 操作时，发现值还是 A，就会误以为没有被修改，从而进行修改，这就是 ABA 问题。</p>
<p>解决办法：使用版本号，让版本号一直递增，将值对比改为版本号对比，比如AtomicStampedReference就是通过这种方式解决 ABA 问题的。</p>
<h3 id="（二）自旋导致-CPU-浪费"><a href="#（二）自旋导致-CPU-浪费" class="headerlink" title="（二）自旋导致 CPU 浪费"></a>（二）自旋导致 CPU 浪费</h3><p>CAS 操作失败时，线程会自旋重试，如果长时间不成功，会浪费大量 CPU 资源。</p>
<p>解决思路：像synchronized的轻量级锁那样，当自旋时间长或线程竞争大时，升级为重量级锁，通过操作系统的互斥锁和线程阻塞唤醒机制来避免 CPU 浪费。AQS（AbstractQueuedSynchronizer）也通过类似的思路解决了这个问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>悲观锁和乐观锁是并发编程中的重要概念，CAS 作为乐观锁的经典实现，其原理涉及软件到硬件的多个层面。理解它们的工作机制、原子性保证以及存在的问题，能帮助我们更好地在实际开发中选择合适的并发控制方式，写出高效且安全的并发代码。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>面试一问AQS怎么实现, 你绞尽脑汁想了半天就蹦出几个词, 什么c a as状态变量, 什么, 等待队列, 问你如何设计一个并发攻击类, 你磕磕巴巴支支吾半天还是答不上来, 这就是你简历上写的精通java, 精通高并发, 精通JUC, 回头look开妈, 那如果让你实现一个并发工具类, 你应该考虑哪些问题呢, 要实现并发工具类, 你得知道啥叫并发工具类啊, 并发工具类就是一个能让多个线程, 安全的去访问共享资源的一个工具, 注意多个线程来访问共享资源, 那每个线程访问的时候, 就要判断当前的共享资源是否正在被占用, 是否正在被访问, 如果没有线程访问共享资源, 那当前线程就能去访问, 如果说已经有线程正在访问共享资源了, 那当前线程要么重视, 要么阻塞, 要么放弃, 那首先要解决的问题就是, 怎么表示共享资源正在被占有, 或者正在被访问呢, 所以我们需要一个状态变量state, 当state为零的时候, 表示资源空闲, state为一, 表示资源被占有, 这也是人称lock的思想, 那么问题来了, state设置为布尔值是不是更好点, 那有没有一种可能, 共享资源也可以同时被好几个线程访问呢, 比如说有些共享资源最多支持三个线程访问, 那这个时候state最多应该为三, 如果你想到这儿, 那么恭喜你, 你了解了SAMHO的设计思想, 还有一种情况在递归调用的场景, 当前线程需要多次的访问这个共享资源, 访问一次split就要加一释放一次, split减一, state的释放到零, 代表资源空闲, 恭喜你, 你发现了react log可重构的设计思想, 考虑到上面这几种情况, 你就会发现state不能是布尔类型, 需要设置为int类型, 那么多线程访问state值, 你得保证可见性啊, 怎么办, 所以还得加上volatile去保证可见性, 那多个线程要修改state值, 你需要保证原子性啊, 怎么办, 使用cs去修改state状态去保证原子性, 当一个线程访问共享资源, 通过CAS去修改state状态, 修改成功了, 就去访问共享资源, 那修改失败了怎么办呢, 一直自旋吗, 长时间的咨询会浪费CPU啊, 怎么办, 所以需要把这些修改失败的线程阻塞住, 等资源空闲了再唤醒, 但是修改失败的线程可能有很多, 怎么去高效地管理这些需要等待的线程呢, 可以把这个线程呢包装成一个一个node节点, 用节点组成一个双向链表, 基于链表去实现一个先进先出的等待队列, 当cs修改state状态失败之后, 将线程加入队列并阻塞住, 当资源释放的时候, 再去把队列里的节点唤醒, 然后呢让他修改state修改成成功之后, 他就可以去访问共享资源了, 看到这儿, 恭喜你, 你已经设计出来了一个简单的并发工具类, 那具体的API应该怎么设计呢, 你得考虑依赖你的上层业务会如何调用, 比如说某个业务, 他只是想尝试获取一下共享资源, 他获取不到就去做其他操作, 针对这种场景呢, 可以设计一个方法叫try acquire, 返回true或者false代表成功或者失败, 那相对的也会出现另外一种场景, 诶, 业务必须获取到共享资源才能继续进行操作, 否则就一直等待, 那就可以设计一个方法叫acquire, 没有返回值, 获取不到就阻塞, 直到其他线程释放的资源自己获取成功为止, 看到这儿, 恭喜你, 你预判了AQS的设计, 来看看AQS源码是怎么设计的, 这里揣了块定义了获取共享资源的方式, 里面没有实现直接抛异常, 那么问题来了, 为什么这么设计, 为什么没有实现, 他要抛异常呢, 因为这里其实是一个并发工具类, 不同的场景获取资源的方式有可能是不同的, 所以并不去定义具体的获取资源的方式, 开放给上层业务去重写该方法, AQS只关心获取资源有没有成功, 再来看另外一个方法, Acquire acquire, 先调用try acquire去获取资源, 获取不到就将节点入队并阻塞, 这里其实也是模板方法模式的一个简单使用, 面试中经常问你, return lock和synchronize有啥区别, 这不就来了, Reaction log, 基于AQSAQS有try acquire啊, 所以return lock可以有try lock去尝试加锁, 加锁失败可以做其他操作呀, 那synchronize就没有, 刚刚说AQS是基于双向链表, 实现了一个等待队列, 那你有考虑过, 为什么AQS这里要实现一个等待队列吗, 除了队列插入删除都是O1实现简单方便之外, 还有一个重要原因就是公平策略, 作为一个并发工具, 你起码要能做公平和非公平策略, 公平, 就说线程按照先来后到的顺序去访问共享资源, 那队列不就是先进先出的吗, 所以AQS的队列结构, 为实现公平策略就提供了基础, AQS的实现类只需要重写try acquire方法, 就可以自定义公平或者非公平策略了, 唉巧了, React lock, 他就是这么做的, 人称log中有一个fire sin和non fire cent的子类, 它们都重写了AQS的try a qu方法, fire think是依赖了AQS的队列结构, 实现了先来先获取锁的操作, non fire sin就允许新线程插队抢锁, 这就是人称的log公平锁和非公平锁的实现, 那面试问你, return lock和synchronize有啥区别, 这不就又来了, return lock基于AQS的等待队列, 实现了公平锁和非公平锁, 而single ize的都是非公平的, AQS有独占和共享两种模式, 共享模式就是多个线程可以共享资源, 适用于多个线程协作的场景, 比如说sam ford或者con lage, 对sam for来说, state就代表许可证的一个数量, 比如当个某个资源可以同时被三个线程访问, 那state就初始化为三, 或许时state递减减到零的时候, 新线程就没有办法访问共享资源了, 就得进AQS那个等待队列去等待了, 当线程释放资源时, state递增, come on lash也是同理, state代表剩余的任务数, 调用抗down时递减, state归零时唤醒所有await的线程独占模式, 就是只允许单线程去独占资源, 适用于互斥的场景, 比如说锁也就是人生的lock独占模式, 通过acquire和try1块去获取资源, 对应的就是人生的lock的lock和try lock, 当state为零时, 表示资源空闲, 加锁cs去修改state, 修改为一代表加锁成功, 枷锁失败就进入AKS的等待队列, state可以代指重入次数, 重入一次加一次, 释放一次减一次, 减到零就完全释放了, 释放了之后唤醒AQS, 等待队列里的线程重新去抢所, 那么问题来了, 上上一期有讲过, synchronized的锁监视器中有所持和等待值, 锁持用来存放货期所失败的线程, 等待时用来放置线程, 通信时主动放弃锁的线程, 那使用了react的log之后, 没有拿到锁的线程放到AQS的等待队列中, 那拿到锁的线程也需要等待资源到位, 调用await, 主动放弃锁之后, 应该被放到哪呢, 这就涉及到了另外一个对象, condition condition用来管理条件队列, 调用了await的线程, 就被放到condition的条件队列中, 然后呢你还可以new多个condition, 就可以配合不同的condition对象的signal方法, 去实现更加精细的唤醒通知, 这又是人称的lock和synchronized, 的另外一个不同了, 了解了这么多之后, 你有没有想过, 为什么AQS它不直接使用操作系统的music, 来限制多线程对共享资源的访问, 而是要自己定义了这么多东西, 首先呢如果直接使用操作系统的music, 它就涉及到了内核态, 涉及到系统调用, 每次加锁解锁都要从用户态切换到内核态, 开销很大, AQS通过用户态的cs和队列管理, 能够一定程度上减少开销, 然后呢AQS它是一个抽象的并发操作的工具, 它能够让子类去自定义公平策略, 自定义共享或者互市模式啊等等, java代码就可以很灵活的去拓展, 但操作系统music, 是没有办法在java层面去做灵活拓展的, 对写简历, 编程学习找工作有任何疑问, 可以进我主页, 点击小店或者充电问答查看,</p>
<h1 id="AQS-基础概念详解"><a href="#AQS-基础概念详解" class="headerlink" title="AQS 基础概念详解"></a>AQS 基础概念详解</h1><p>在 Java 并发编程中，AQS（AbstractQueuedSynchronizer，抽象队列同步器）是许多并发工具类的基础，像 ReentrantLock、Semaphore、CountDownLatch 等都是基于 AQS 实现的。但很多开发者在面试中被问及 AQS 时，往往只能说出几个零散的词汇，无法清晰阐述其原理。本文将从基础概念入手，带你逐步了解 AQS。</p>
<h2 id="一、AQS-的定义"><a href="#一、AQS-的定义" class="headerlink" title="一、AQS 的定义"></a>一、AQS 的定义</h2><p>AQS 是一个抽象类，它为实现依赖于先进先出（FIFO）等待队列的同步器提供了基础框架。它的主要作用是为并发工具类提供统一的同步机制，帮助开发者更轻松地实现各种同步器。</p>
<h2 id="二、AQS-的核心组成"><a href="#二、AQS-的核心组成" class="headerlink" title="二、AQS 的核心组成"></a>二、AQS 的核心组成</h2><h3 id="（一）状态变量（state）"><a href="#（一）状态变量（state）" class="headerlink" title="（一）状态变量（state）"></a>（一）状态变量（state）</h3><p>状态变量是 AQS 的核心，用于表示共享资源的占有情况。它有以下特点：</p>
<ul>
<li><p><strong>类型</strong>：为了适应多种场景，state 被定义为 int 类型，而不是布尔类型。比如在 Semaphore 中，state 表示可用的许可证数量；在 ReentrantLock 中，state 表示重入次数。</p>
</li>
<li><p><strong>可见性</strong>：由于多个线程会访问 state，所以需要用 volatile 修饰 state，以保证其在多线程间的可见性。</p>
</li>
<li><p><strong>原子性</strong>：当多个线程修改 state 时，需要保证操作的原子性，这通常通过 CAS（Compare and Swap）操作来实现。</p>
</li>
</ul>
<h3 id="（二）等待队列"><a href="#（二）等待队列" class="headerlink" title="（二）等待队列"></a>（二）等待队列</h3><p>当线程尝试获取共享资源失败时，AQS 会将这些线程包装成节点（Node），并将节点加入一个双向链表实现的等待队列中。等待队列遵循 FIFO 原则，这样可以保证线程获取资源的公平性（在公平锁的实现中）。</p>
<p>每个 Node 节点包含以下主要信息：</p>
<ul>
<li><p>当前线程</p>
</li>
<li><p>前驱节点和后继节点（用于构成双向链表）</p>
</li>
<li><p>线程的等待状态（如是否被取消、是否需要唤醒等）</p>
</li>
</ul>
<h2 id="三、AQS-的核心操作"><a href="#三、AQS-的核心操作" class="headerlink" title="三、AQS 的核心操作"></a>三、AQS 的核心操作</h2><h3 id="（一）获取资源（acquire）"><a href="#（一）获取资源（acquire）" class="headerlink" title="（一）获取资源（acquire）"></a>（一）获取资源（acquire）</h3><p>线程获取资源的过程如下：</p>
<ol>
<li><p>线程通过 tryAcquire 方法尝试获取资源，该方法需要子类根据具体需求实现。</p>
</li>
<li><p>如果获取成功，线程可以直接访问共享资源。</p>
</li>
<li><p>如果获取失败，线程会被包装成 Node 节点，加入等待队列并被阻塞。</p>
</li>
</ol>
<h3 id="（二）释放资源（release）"><a href="#（二）释放资源（release）" class="headerlink" title="（二）释放资源（release）"></a>（二）释放资源（release）</h3><p>线程释放资源的过程如下：</p>
<ol>
<li><p>线程通过 tryRelease 方法尝试释放资源，该方法也需要子类实现。</p>
</li>
<li><p>释放资源成功后，会唤醒等待队列中的一个或多个线程，让它们有机会重新尝试获取资源。</p>
</li>
</ol>
<h2 id="四、AQS-的模板方法模式"><a href="#四、AQS-的模板方法模式" class="headerlink" title="四、AQS 的模板方法模式"></a>四、AQS 的模板方法模式</h2><p>AQS 采用了模板方法模式，它定义了一些核心方法的骨架，而将具体的实现细节交给子类。其中，tryAcquire 和 tryRelease 等方法就是模板方法，需要子类重写，以实现不同的同步逻辑。而 acquire、release 等方法则是模板方法，它们调用 tryAcquire 和 tryRelease 等方法，实现了获取和释放资源的整体流程。</p>
<p>这种设计模式的好处是，子类可以根据自己的需求灵活地实现同步逻辑，而无需关心等待队列的管理、线程的阻塞和唤醒等底层操作，从而简化了并发工具类的实现。</p>
<h2 id="五、AQS-的两种模式"><a href="#五、AQS-的两种模式" class="headerlink" title="五、AQS 的两种模式"></a>五、AQS 的两种模式</h2><p>AQS 支持两种资源共享模式：</p>
<ul>
<li><p><strong>独占模式</strong>：同一时间只能有一个线程获取资源，如 ReentrantLock。</p>
</li>
<li><p><strong>共享模式</strong>：同一时间可以有多个线程获取资源，如 Semaphore 和 CountDownLatch。</p>
</li>
</ul>
<p>在独占模式下，线程获取资源后，其他线程必须等待该线程释放资源才能获取。在共享模式下，多个线程可以同时获取资源，直到资源被耗尽。</p>
<p>通过理解 AQS 的这些基础概念，我们可以更好地掌握基于 AQS 实现的各种并发工具类的原理，从而在实际开发中更合理地使用它们，同时也能在面试中从容应对相关问题。</p>
<h2 id="Threadlocal"><a href="#Threadlocal" class="headerlink" title="Threadlocal"></a>Threadlocal</h2><p>一提thread local, 大家都知道每个线程都有一个变量副本, 各个线程之间相互隔离, 那你有没有考虑过, THRELOGO中的数据到底是怎么存的呢, 为什么key要做一个弱引用呢, 那value为啥不是弱引用呢, 既然key是弱引用, 那JC之后key一定会被回收吗, 一定会变成none吗, 如果key为none的话, 那slocal map中会不会有大量的key为none的数据, 那怎么清理呢, sr local为啥容易内存泄漏呢, 那怎么去避免内存泄漏呢, 失眠盗汗力不从心, 精神不振, 感觉大脑时常被面试官掏空, 虽然logo中的数据到底是怎么存的呢, </p>
<p>首先每一个线程内部呢有一个threlocal map, 它其实就是一个HASHMAP, 底层用一个entry数组来存数据, ENTROL的key呢是一个sr local的一个弱引用, value呢就是要保存的一个资源, 调用set方法的时候, 其实就是以当前的THRELOCAL对象为key, 以资源为value, 然后放到这个threlocal map里面, 调用get方法的时候, 就是以当前的sr local对象为key, 然后从这个map里面取值, 开发中我们一般把thread local声明为static的一个变量, 这个时候SLOCAL对象就是所有线程共享的了, 那么问题来了, key的共享的都是一样的, 那不同线程取出来了value, 那不就是同一个了吗, 哎这你不用担心啊, threlocal map是每个线程私有的, 每个线程的threload map都一样的, 各有一份, 所以即便有相同的key, 从不同的thread map取出来的值肯定也是不一样的, 那为什么key要做一个弱引用呢, 因为要避免key的内存泄漏问题, 那为啥会出现内存泄漏呢, 怎么平时也不说内存泄漏, 一说THRELOCAL就说容易出现内存泄漏呢, 我们正常new一个对象的时候, 基本上都是一些局部变量方法, 执行完了JC就把这些对象清理了, 回收了, 如果你整一个全局的map或者list, 然后一直往里面存东西也不清理, 那也会出现内存泄漏, 一般来说这种全局的map或者list都是本地缓存, 或者其他的第三方库中会用到的, 内存泄漏的情况, 一般第三方库都帮你处理好了, 不需要开发人员担心, 那si logo的内存泄露是什么原因呢, 怎么就需要开发人员操心了, 如果说我们正常去new thread, 用完之后正常销毁, 那thread类中的thread local map这个属性也就会被GC回收了, 不会出现内存泄漏问题, 但是项目中其实没有人直接new thread, 都是直接使用线程池, spring boot项目处理请求的时候, 也是从线程池中拿出来一个线程, 然后去处理请求的线程池中的线程也不会销毁, 会一直复用, 也就是说会一直存在一条引用链, 从thread到THRELOCAL, map到entry到key, 然后再到THRELOCAL, 即便我们不想用thread local了, 把这个thread local对象设置为N, 但是这条引用链还是存在的, entry对key的这个引用也是存在的, 这个key对应的虽然local他已经不用了, 但是还是没有办法被JZ回收, 所以要把这个key设置为弱引用, 如果他只被弱引用关联的话, 那么只要发生了垃圾回收, 它就能够被直接回收, 从而避免内存泄漏问题, </p>
<p>那么问题来了, 既然key是弱引用, 那么JC之后key一定会被回收吗, 它一定会变成none吗, 不一定, 弱引用被GC回收的前提是, 这个对象只有弱引用关联, 没有其他的引用, 那如果THRELOGO对象没有被设置为none的话, 那么还有一个强引用指向它, 所以你就得把THRELOGO对象设置为none, 强烈引用才会断开, 就只剩下了entry的key的弱引用, GC才能自动回收, 那threlocal map, 会不会出现大量key为none的数据呢, 你能想到的, 其实JDK的开发人员早就想到了, 当我们去调用THRELOGO的get set, 或者remove方法的时候, 就会便利entry数组清理掉key为N的无效的entry, 然后呢通过线性探测法重新去处理哈希冲突, 这个时候可能会有一些非科班的同学在想, 啥叫线性探测法呀, 数据结构哈希表那一节, 处理哈希冲突有很多种方法, java的哈希map用的是拉链法, 通过数组加链表去实现, 虽然threlocal map这里也是一个哈希map, 但是处理哈希冲突的方法呢, 使用的是线性探测法, 当一个P放入到数组中的时候, 数组这个位置已经有数据了, 这就是发生了哈希冲突, 那么就往数组的下一个位置放, 下一位也有了, 就往下下一个位置放, 这就是线性探测法, key是弱引用, 说完了, 那为啥value不是弱引用呢, 我们把数据存到value中, 是为了后面去用它, 如果value中是弱引用, 那现在代码里可能还没有用value, 那也就是说暂时还没有强引用去指向这个value, 那value中只有弱引用, 那这些之后呢就错误的把这个value回收了, 但是value后面可能还要去获取去用呀, 所以value不能直接被GC回收, 它必须是强引用, 那么问题来了, value是强引用的情况下, 后续我们的业务代码不用value了, 不去引用value, 那也会一直存在着, 从thread到THRELOGO, map到entry到value的引用链, 这些是无法回收的, 导致value的内存泄漏, 那么怎么办呢, 所以在使用完si logo之后, 必须调用remove方法, 手动断开value的一个强引用, 然后呢让GC去把它回收了, 虽然local和锁都是为了解决并发安全问题, 那有啥不同呢, 所的思想是共享资源只有一份, 强制让多个线程必须互斥访问, 虽然logo的思想是把这个资源复制多份, 每个线程一个副本, 各防各的不冲突, 其实sr local这个思想呢也是处理死锁的一种思想, 如果说你学过操作系统, 那你就知道死锁有四个必要条件互斥呀, 不可剥夺呀, 请求保持条件循环等待条件啊, 卧室条件就是说共享资源必须互斥访问, 不能被同时访问, 虽然logo的思想就是, 就让每个线程操作自己的数据副本, 一人一个, 大家各防各的, 这不就破坏了忽视条件了吗, 这个请求保持条件也挺有意思, 他说的是多个县城各占有一份资源, 同时还在请求其他县城的资源, 而且每个县城都不愿意放弃自己的资源, 从而形成互相等待, 形成思索的这么一个现象, 举个例子啊, 就线程一和线程二需要获取两个锁, A和B才能够继续执行, 如果线程一持有锁A然后呢, 并尝试去获取所B那同时线程二呢持有锁B, 然后尝试去获取所A, 双方互相等待, 就有可能产生思索, 那上一期视频聊过的return lock, 有个try lock方法, 尝试加锁, 加锁失败就可以做其他操作, 通过这个其实就可以设置一种机制啊, 如果说不能一次性获取所有的唢呐, 主动释放自己已持有的锁, 把线程一持有所A尝试或其所B那使用try lock, 发现获取失败, 然后呢释放所A再次重试, 这就打破了一个请求保持条件, 解除了一个死锁.</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>不知道你面试中有没有被面试官拷打过, 为什么java中线程创建和销毁的开销比较大, 线程池的原理是什么, 怎么样才能让线程池不去拒绝任务, 动态参数的线程池应该怎么设计, 或者说怎么在不重启应用的情况下, 动态的调整线程池的核心参数, 那怎么去监控线程池的状态, 或者说怎么自己设计一个简单的线程池监控呢, 失眠盗汗, 力不从心, 精神不振, 感觉大脑时常被面试官掏空, 当有大量的任务需要被执行的时候, 你就想到了使用多线程, 正要new thread, 调用start方法的时候, 又想到了幼儿园老师曾经教过的啊, 县城资源很昂贵啊, 频繁的创建和销毁开销很大呀, 那为什么县城的创建和销毁开销比较大呢, java线程模型是一对一的, 也就是说, 一个java线程对应了一个操作系统的内核级线程, 那创建一个java的线程, 就需要通过系统调用, 让操作系统切换到内核态去创建内核级线程, 这就涉及到了内核态的切换, 涉及到线程资源的分配, 占空间的分配, 同样的销毁线程也需要操作系统切换到内核态, 去回收这些资源, 所以java中线程的创建和销毁的开销非常大, 然后呢加21呢就出现了虚拟线程, 虚拟线程或者说携程它就是多对多的线程模型, 基于用户态的调度, 所以很轻量级, 但是你看这项目中的java8陷入了沉默, 那既然java8线程的创建和销毁开销都比较大, 那有没有一种可能可以把创建好的线程, 放入到一个容器中, 需要用的时候再去拿, 然后用完之后我也不销毁, 而是放回去, 那这样每次复用容器中已存在的线程, 就能避免线程频繁的去创建和销毁了, 这就是我们幼儿园老师经常说的线程池, 那么问题来了, 一般情况下, 线程池中的线程也就十几个几十个, 但是要处理的任务往往有上百上千个, 你把线程累死, 给CPU干冒烟了, 他一下子也处理不完呀, 那线程处理不完的任务怎么办, 排队等待, 搞一个阻塞队列, 把暂时处理不完的任务放到阻塞队列里面, 当线程处理完手头这些任务, 从阻塞队列中拿出任务再进行进行处理, 那么问题来了, 阻塞队列的大小是有上限的, 那阻塞队列满了怎么办, 队列满了说明任务量很多, 当前系统的压力比较大, 那我们可以再新建一些临时的线程, 来紧急的处理, 那如果队列中的任务都执行完了, 临时线程也空闲了, 是不是应该销毁呢, 队列中都没任务了, 说明系统不忙了不忙了, 这些临时工肯定不用了, 都要销毁的, 所以需要设置一下, 临时线程的这个最大空闲时间, 超过十个时间之后就直接销毁, 那么问题又来了, 如果任务量它就是很大, 阻塞队列满了, 临时线程也都在忙, 这时候来了新任务应该怎么办, 这就定义一套拒绝策略来拒绝这些任务了, 那么问题又又来了, 这个线程池应该以什么样的方式创建线程呢, 应该创建什么样的线程呢, 普通线程还是守护线程, 那创建线程的时候应该怎么给线程命名呢, 所以最好要搞一个县城<strong>工厂来统一负责, 创建线程, 顺便可以根据业务去给线程和线程池去命</strong>名, 这样的话, 业务出问题就能定位到对应的线程池和线程, 线程出了问题也能定位到具体的业务, 所以这也说明了, 不同的业务共用一个线程池肯定是不好的, 不同的业务最好要用不同的线程池, 以上呢就是线程池的七大参数了, 核心线程数最大线程处临时线程的空闲时间, 时间单位阻塞队列, 拒绝策略, 现成工厂, OK总结一下线程池的执行流程, 当一个任务被提交到线程池的时候, 如果核心线程空闲, 那就交给核心线程去执行, 否则尝试放入阻塞队列, 如果阻塞队列没满就入队, 如果满了就创建临时线程进行处理, 如果说堆叠满了, 而且临时线程都在忙, 那就触发拒绝策略, 那么问题来了, 我不想拒绝任务怎么办, 有些大聪明就要说了, 可以把阻塞队列设置的大一点, 设置成无界队列, 这样的话来再多的任务他都能容纳下去, 就不用拒绝了, 队列可以是无界的, 但服务器的内存有限呀, 随着任务越来越多, 内存肯定会满, 最后频繁的GC, 然后触发OM, 那咋办呢, 有个拒绝策略叫collar runds policy, 就是谁往线程池中提交任务, 谁就去执行这个任务, 这种方式确实可以避免丢弃任务, 但是让业务线程去执行这些任务, 可能会导致业务线程被拖慢, 没有办法去及时去处理前端发的请求, 所以这个拒绝策略只能适用于低并发, 而且不想丢弃任务的场景, 你又想性能好, 又不想丢弃任务, </p>
<p>那怎么办呢, 你想想操作系统中学到的内存和磁盘, 想要内存中的数据不会断电, 丢失就要持久化到磁盘中, 想想操作系统中虚拟内存中的请求分页, 当无法加载所有数据到内存的时候, 只加载必要的需要其他数据触发缺页中断, 然后呢从磁盘中读入内存, 所以线程池想要任务不被丢弃, 就要做任务持久化, 那就自定义拒绝策略, 把需要拒绝的任务存到MYSQL或者REDIS或者MQ中, 然后呢重写线程池的after execute方法, 当线程池执行完一个任务的时候, 说明此时线程池有可能空闲了, 那么就判断一下哦, 我这个线程池中阻塞队列的大小, 如果说紫色队列还比较空, 空前的还比较多, 那么读取MYSQL或者REDIS或者MQ中的持久化的任务, 然后放入线程池的这个阻塞队列中再进行处理, 这样就做到了不丢弃任务, 除了重写after execute方法之外, 还可以自定义组合队列, 当线程从阻塞队列中取任务的时候, 判断阻塞队列中任务量的多少, 如果阻塞队列中任务比较少, 那就从MYSQLREDISMQ中去读数据, 读取那些持久化的任务, 然后呢读到阻塞队列任务, 然后线程池就可以执行这些任务了, 这也做到了不丢弃任务, 那动态参数的线程池应该怎么设计, 或者说怎么在不重启应用的情况下, 动态调整线程池的核心参数, 其实线程池呢本身提供了一系列的set方法, 能够让你在运行的时候去修改核心参数, 比如说set什么corple size, set max posize等等的, 调用set方法就能去动态的修改核心线程数, 最大线程数等等这些参数了, 然后呢把这些配置放到配置中心里面, 线程池去监听配置中心, 当配置中心发生了配置变化的时候, 线程池呢就能够监听到了, 然后呢动态的去修改这些参数, 但是有一个问题啊, java中的阻塞队列的容量是这个final修饰的, 也就是说阻塞队列的大小是不可变的, 这里你要想实现阻塞队列大小可变, 想要实现动态的阻塞队列, 那就得自己重新写一个大小可变的阻塞队列, 这样就实现了不重启应用, 修改配置中心的这个配置, 就可以动态的去调整线程池的核心参数了, 那怎么监控线程设置的状态呢, 或者说自己怎么设置一个简单的线程池监控呢, 第一步你得定义一系列的线程池指标呀, 比如说活跃线程数, 线程池的当前线程数, 阻塞队列大小已经完成任务数, 总任务数等等等等的, 第二步你得收集这些指标呀, 怎么收集呢, 你可以用定时任务, 每隔几秒采集一下这些指标数据, 那也可以重启after execute, 或者这种before execute方法, 在执行前后, 或者说在任务提交的时候去采集这些指标数据, 然后呢, 第三步, 把这些指标数据上报到这个监控系统里面, 第四步, 通过可视化图表的方式去展示这些指标数据, 就可以了</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>了解过jm m吗, 为什么要有jm m, 知道八种内存交互操作吗, 为什么要有这八种内存交互操作, 了解过内存屏障吗, 那为什么需要内存屏障呢, 了解过happen before规则吗, 原子性可见性, 有序性如何保证呢, 失眠盗汗, 力不从心, 精神不振, 感觉大脑时常被面试官掏空, 要聊gm m就得从计算机的发展史说起, 因为磁盘的速度太慢了, 所以引入了内存, 运行程序的时候, 先把磁盘中的数据读入内存之后, 然后再运行, 这就大大提高了速度, 内存相比于磁盘来说, 其实就是一种缓存, 但是相比于CPU的高速来说, 内存还是太慢了, 所以就有了CPU缓存, 有了缓存之后, 那CPU怎么工作呢, CPU运行程序的时候, 先把数据从主存读到缓存, 然后呢CPU直接从缓存中读取数据, 运行速度就更快了, 当CPU运算完之后, 再把数据回接到储存当中, 那CPU的缓存呢分为三级啊, 一级和二级是CPU核心私有的, 第三级呢是共享的, 那么问题来了, 当一个CPU核心执行某个线上任务, 当他修改了缓存中的数据, 但是缓存中的数据还没有同步到主存中, 其他CPU核心去执行另外一个线程任务, 它从主存中读到的数据不就是脏数据了吗, 一个线程修改了共享数据, 另外一个线程无法立即获得最新的共享数据, 这就是可见性问题, 那么问题又又来了, 在执行代码的时候, 为了提升执行速度, CPU或者编译器可能会对指令进行重排序, 导致执行的顺序和代码的顺序不一致, 指令重排序, 可以保证单线程串行执行的语义一致性, 但是没有办法保证, 多线程并发执行的语义一致性, 所以在多线程去访问一个共享变量, 指定床排序就有可能导致一系列的问题, 这就是有序性问题, 那么问题又又又来了, 在多线程并发的环境中, 比如说线程A读到的库存是一, 正想做库存减一的操作, 但是他只是读到了, 还没有执行呢, 正准备执行简易的操作, CPU的时间片运又用完了, 耗尽了线程B拿到时间片开始执行, 把库存减一, 此时库存变成了0, 然后呢线程一再执行减一的操作, 库存就是一了, 那库存能是负数吗, 肯定不能啊, 所以一个线程去执行一系列不可分割的操作时, 但是执行过程中却被其他线程插手了, 这就是原子性问题, 所以整个并发编程的核心就是去解决, 可见性有序性, 原则性问题, 操作系统通过内存模型呢定义了一系列规范, 去解决这些问题, 但是不同的操作系统的内存模型它是不同的, 如果java他直接复用操作系统的内存模型, 去解决这些问题, 就有可能会导致同样一套代码, 我换了个操作系统, 它就无法执行了, 但是java当时的口号是什么, 一次编译处处运行, 为了达到跨平台的目标, 所以java需要自己去提供一套内存模型, 去屏蔽不同操作系统之间的差异, 这就是java内存模型JMM, 那JMM干了啥呢, 怎么解决问题的呢, GMM定义了一套并发编程相关的规范, 抽象了缓存线程储存之间的关系, 去解决这些问题, 咋抽象的呢, 之前聊过CPU执行命令, 需要把主存中的数据读到缓存中, 然后再读到寄存器中再进行计算, 所以gm将寄存器缓存这些私有的东西统一抽象, 为了现成的工作内存, 这个工作内存, 这是线程私有的一个计算区域, 每个线程的工作内存都是相互独立的, 线程必须把主存中的数据读到自己的工作内存, 然后再进行计算, 计算完之后再刷新回主存中, 也就是说, 当某个线程修改了工作内存, 需要和其他线程共享数据的时候, 必须把自己工作内存的数据刷回到主存中, 再让其他线程读取, 抽象出了工作内存之后, JMM就需要规定一套主存和工作内存之间, 的交互方式去读写数据, 简单来说就是一个共享变量, 怎么从主存拷贝到工作内存, 又怎么从工作内存同步到主存的, 针对这个问题, jm m规定了八种储存和工作内存交互的, 原子操作, 哪八种呢, Lock unlock, Read load, Use assign store write, 这套东西大家也不用刻意去记啊, 其实你真正理解了一下子就全会了, 无非就是规定储存怎么和工作内存去交互, 首先呢就是能对主存进行加锁, 然后呢从主存读数据到工作内存, 然后呢把数据赋值给工作内存变量, 然后交给执行引擎去执行, 然后把执行的结果再赋值给工作内存的变量, 然后呢再把工作内存的数据传到主存中, 然后呢写入主存变量, 最后解锁, 除了八种内存交互操作之外, gm m还规定了做操作时必须满足的一系列规则, 那内存操作和规则只是定义了数据交互的方式, 只是定义了可以做什么, 但没有规定什么时候做, 具体怎么实现一个顺序的保证, 所以JMM需要通过内存屏障去保证, 内存操作的顺序性和可见性, 内存操作呢是一种CPU指令啊, 主要有四种, 第一种叫loadload, 就禁止屏障前后的这个读操作的一个重排序, 其实就是禁止纯读操作的一个重排序, 第二种呢叫storestore对吧, 禁止写操作的重排序, 然后呢load store禁止读操作和写操作重排序, 然后呢snow load禁止所有重排序, 举个例子啊, Volatile关键字呢有三个特点, 能保证有序性, 可见性, 无法保证原子性, 有序性怎么保证的呢, 就是插入的内存屏障禁止了指令的重排序, 可见性呢就是说一个线程修改的状态, 能对另外一个线程是可见的, 线程每次获取word tt修饰的变量的时候, 都能够获取到最新值, 那可见性怎么保证的呢, 其实就是在告诉JVM, 当前变量在工作内存中的值是不确定的, 需要从主存中去读, 本质上其实就是禁用的CPU缓存, 每次必须从主存中取值, 八种内存交互操作, 在底层呢操作内存, 数据内存屏障呢规定顺序和可见性, 但是从程序员写代码的角度来看, 你写一段代码, 还是不知道编译器和处理器怎么重排序的, 怎么优化的, 什么时候漏的了, 什么时候可见的, 不知道啊, 你不知道实际的执行顺序, 你就不知道线程A做的操作, 线程B是否能看见, 这就很可怕了, 所以gm m通过happiness before规则呢, 向程序员做了一个内存可见性的保证, happiness本before规则就是可见性的一个逻辑抽象, 它不关心底层怎么实现的, 它只规定如果a happens before b, 那A的结果必须对B是可见的, happen before规则呢一共有八条, 我这里随便列举几条啊, 比如说线程顺序规则, 一个线程之内按照代码顺序写在前面的操作, Have is before you, 写在后面的操作, 也就是说, 单线程内前面的代码操作对后面是可见的, 再比如解锁规则, 解锁happen before于加锁, 再比如说线程启动规则, thread对象的start方法, happen before与线程的每一个操作, 再比如说传递规则, 如果a happens before b b happens before c, 那么A1定happens before c, 也就是说A对B可见, B对C可见, 那A1定对C是可见的, 当程序员知道happiness before规则之后, 只需要知道两个操作满足规则, 那就有顺序性保证, 那就是可见的, 那如果这两个操作不满足规则, 那么JVM就可以随便的对这两个操作, 进行重排序, 了解了这些, 再回头看可见性, 有序性, 原子性三个问题, java在上面的一系列东西的基础上, 提供了一套并发工具, 让开发者能够直接使用去解决可见性, 有序性, 原子性三大问题, 从而避免并发安全问题, 那最核心的并发工具类有哪些呢, 第一个synchronized可以直接保证可见性, 有序性, 原子性, 第二个one tap可以保证可见性有序性, 第三个cs可以保证原子性, 有cs呢又衍生出了一系列无锁的并发工具, atomic原子类, 人称lock count lage等等, 对写简历, 编程学习找工作有任何疑问, 可以进我主页, 点击小店或者充电问答查看,</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>那你讲一下啥叫索引, 为啥需要索引, 查字典的时候, 你是一页一页翻去找字, 还是先翻目录, 通过目录定位到你想查那个字呢, 肯定是通过目录查呀, 因为目录快呀, 这里的目录其实就是一种索引, 通过空间去换时间的一个思想, 加快查询速度, 那从数据库层层面来说呢, 索引就是一种能够快速查找的数据结构, 能够加快SQL执行速度的那字典, 一页一页翻找的这种形式就是全表扫描, 通过目录查数据, 就是索引查询, 所以执行SQL肯定走索引快呀, 全表扫描肯定慢呀,</p>
<p>如果让你设计, 你觉得数据库用哪种数据结构做索引比较好, 常见的能快速搜索数据结构有哈希表, 二叉排序树, 平衡二叉树, 红黑树, B树B加数等等啊, </p>
<p>哈希表呢用唯一的key去查对应的value啊, 时间复杂度O1, 它很快, 但是没办法做范围查询, 也没办法排序</p>
<p> 二叉排序数呢左节点小于根, 右节点大于根, 中序遍历它就是有序的, 所以他可以做排序, 也可以范围查询, 但是二叉排序数顺序插入的情况下, 他会退化为链表, 性能就会很差, 那怎么办呢, </p>
<p>平衡二叉树对吧, 平衡二叉树插入节点, 使用旋转操作, 让这个二叉树去保持平衡是吧, 左右子树的高度差不大于一，能够避免极端情况下退化为链表, 但是由于平衡拉出, 它追求绝对完美的平衡, 会导致频繁的左旋右旋就保持平衡, 但应用于数据库中, 当插入删除的时候, 频繁旋转就会带来大量的磁盘IO, 降低性能, </p>
<p>那再升级一下红黑树, 红黑树也是一种自平衡的二叉排序树, 通过插入删除数据的时候去变色呀, 旋转呀, 让树保持平衡, 但是红色压叉树它不追求绝对的平衡, 只要大致平衡就可以了, 这就大大的降低了插入删除需要的, 这个旋转操作, 应用到数据库中, 就减少磁盘IO, 但是啊红黑二叉树它是一种二叉树, 一个节点只能有两个孩子, 存储大量数据的时候, 数高就会很高, 那排序数的查找性能和数高是直接相关的, 这导致了存大量数据的时候, 红黑树的查找性能其实没那么好, 要多次的磁盘IO, 所以呢, 红黑树其实适合存储少量数据的内存操作, 像java的哈希map, 当某个桶数据量超过阈值的时候, 链表呢就会转化为红黑树, 而当整个哈希map数量比较多的时候, 那它也能平均的分配到每个桶里面, 每个桶都可以对应一个链表或者二叉树, 然后这样的话单个红黑树存的数据也不会很多, 而且纯内存操作也比较快, 那它是一个二叉树呃, 高度太高不行了, 那有没有一种方法呢, 可以用</p>
<p>B树, B数是多路平衡排序数, 一个节点它有N个孩子, 数据量大的情况, 数高也不会像红黑树那么高, 但是B数的节点呢又存数据, 又存索引值, 就导致了B数的一个节点存不了多少索引, 树高就会变得比较高, 而且B数做范围查询的时候, 他需要回溯整个数据结构, 效率比较低, 会产生很多的随机IO, 所以B数也不行, </p>
<p>得上B加数, B加数也是这种多路平衡排序数, 而且B加数的非叶子节点只存索引值, 它不存数据, 那不存数据, B加数单个节点能存的索引值就变多了, 树的高度是更低的, 查询性能更好了, B加数的数据呢只存在于最下面的叶子节点, 而且叶子节点呢由双向链表去连接范围, 查询呢只需要遍历链表就可以了, 不用回溯数据结构, 所以性能是更好的, 所以呢像MYSQL这种数据库, 就会选用B加数来保存索引, </p>
<p>那B加数具体是怎么存储数据的呢, MYSQL索引从存储结构上划分主要有两种啊, 聚集索引和非聚集索引, 也有叫聚簇索引和非聚簇索引的, 就是换了个名而已, 本质上是一样的, 聚集索引就是说索引值和数据一块存, 非聚集索引就是说索引值和数据分开存, 举个例子啊, 像主键索引它就是聚集索引, 非叶子节点它都是索引值, 然后叶子节点呢保存全部的索引值, 和对应的行数据啊, 这里索引值就是id对应的行数据, 就是那一行的存的数据啊, 然后呢主键在B加速中, 这也就决定了那主键应该自中插入, 因为如果说不自增的话, 它会到来, 导致这个页分裂带来的性能问题, 像MYSQL中的唯一索引啊, 普通索引啊, 前缀索引啊, 它这种东西就是二级索引或者叫非聚集索引, 这种索引呢非叶子节点存储索引值, 叶子节点去存储索引值和对应的主键id, 所以查询的时候, 他需要先根据索引列也去查出对应的主键id, 然后呢再根据主键id去查主键索引, 然后呢查出对应的行数据, 这也就说为啥叫二级索引, 因为他先查自己的索引数, 去查主键id, 然后再查主键的索引数去查出行数据, 这个过程呢叫回表, 所以这里也可以看到回表, 它会降低查询效率, 所以很多SQL优化其实就是要避免回表, </p>
<p>那查二级索引一定会回表吗, 不一定啊, 如果我们只查id, 那二级索引树的叶子节点就有id呀, 我们所以就可以直接只查二级索引数, 就没必要回表查询了, 这就提高性能, 当一个索引包含所有需要查询字段值的时候, 那就可以不回表这种情况, 那叫覆盖索引, 所以减少回表查询就是要尽可能做到覆盖索引, 如果一个索引列有多个字段, 那就能大大增加所覆盖索引的概率, 这种索引呢就是联合索引, 所谓联合索引呢, 就是针对表中的多个字段去创建索引呃, 举个例子啊, 你对姓名年龄两个字段去建立联合索引, 那索引列就是姓名和年龄, 所以树的叶子节点呢还挂了id, 那如果我去执行什么select id, 姓名年龄, where r姓名等于多少多少多少多少, 那就可以走联合索引, 然后呢直接就能查到id姓名年龄, 就能避免回表提升性能, 所以减少回表查询的方式之一呢, 就是创建联合索引, 然后尽可能的去避免使用select星啊, 因为select星查到的所有的列数据, 它就会很容易触发回表, </p>
<p>你提到联合索引, 那讲一下最左前缀匹配法则吧, 联合索引因为有多个索引列, 所以排序的时候会根据索引列的顺序去排查, 找的时候会根据索引列的顺序, 从左到右依次匹配, 比如说建立联合索引ABC，MYSQL底层建B加数的时候, 会先去根据A去排序, 再根据B去排序, 再根据C排序, 所以查询的时候得先从A开始查, 如果A不存在, 那BC是乱序的, 同样的, 如果AB不存在, C一定是乱序的, 他无法跳过前面的索引列去匹配, 所以必须从左到右依次使用索引列去匹配, 举个例子啊, 建立联合索引ABC查询的条件是where a等于一, and b等于二, 会走索引吗, 显然是会的, 最左边的A和B都有, 那查询条件为WhereB等于二, and a等于一, 会走索引吗, 也是会的, 只要有A有B就可以了, 书写顺序无所谓, MYSQL的优化器, 它会自动把索引列重排序的, 那查询条件为whereA等于1and c等于二, 会做索引吗, 会走部分索引, A会走索引, C的部分无法走索引, 因为按照索引顺序, C的左边是B, 查询的时候没有B那C的部分就无法走索引了, 因为你无法保证AB有序的话, 那C就是乱序的好吧, 那查询条件为whereB等于一, 然后那C等于二会走索引吗, 完全不会走, 因为A在最左边, BC的有序是建立在A上的, 就无法走索引了, </p>
<p>那讲一下, 在其他索引失效, 查比如说模糊查询场景中啊, name like王百分号对吧, 这种百分号在后面的尾部模糊, 所以是生效的, 因为所以从左往右匹配那个王是存在的, 可以根据王去匹配, 那where are name, 来个百分号王, 那头部模糊了, 所以就失效了, 因为前面的数据没有了, 从左右往右匹配, 左边没有数据, 没有办法搜索匹配好吧, 然后呢索引列运算的时候, 或者函数运算的时候也会让索引失效, 因为B加数存的是索引值, 你一计算一使用函数, 那就无法确定在B加数的位置了, 然后呢再去做这种隐式类型转换的时候, 也会让索引失效, 因为隐式类型转换就会触发case的函数去做转换, 这就间接的调函数了, 再比如用or的时候出现了非索引列, 比如说or1边有索引, 一边没索引, 那就完全没办法走索引了, 因为你不能同时做索引扫描和全表扫描呀, 所以就直接退化成全表扫描, 索引失效的例子还有很多啊, 但是只要你理解索引查找的基本原理, 这些索引失效你就全部能看懂了</p>
<p>那所以这么快全部加上索引不就好了, 索引呢就像字典里面的目录啊, 如果你加过多的索引, 那目录就会越来越多了, 占用的空间就会越来越大了, 如果目录占用的空间都改成正文了, 那还要正文干嘛呢, 那就坏了, 所以所以呢并不是越多越好, 而且所以会降低增删改的性能, 因为你增删改的数据, 那同时要更新对应的索引, 所以索引肯定不是越多越好, 也不是万能的, </p>
<p>那怎么加索引比较好, 数据量比较大的查询频繁的就适合加索引, 经常where group by order by的列呢适合建索引, 增删改频繁的就不适合加索引了, 对于区分度比较高的列也比较适合做索引, 像身份证号这种的, 但性别这种区分度很低的就不适合加索引, 那整个B加数全是一边男一边女, 加索引也提高不了效率, 然后呢对于比较长的这个字符串, 可以使用前缀索引, 然后呢要尽量的多用联合索引, 而不用单列索引, 因联合索引很多时候可以覆盖索引嘛, 避免回表, 所以能提升效率, 然后呢就是要注意一张表的索引呢不能太多, 最多不要超过五个, 不然会大大降低插入和删除的效率, 但怎么知道要不要加索引, 怎么判断一个circle是否走了, 所以呢可以打开MYSQL的慢查询日志啊, 慢查询日志, 他就记录了执行时间超过阈值的所有查询语句, 这样就能找到MYSQL了, 然后呢, 可以使用explain执行计划去对MYSQL进行分析啊, 查询是否走了, 索引走了什么索引, 然后针对性的做优化就可以了,</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>信不信我可以几分钟就教会你数据库事务, 数据库事务无非就是要解决以下几个问题, 啥叫数据库事务, 为啥要有事务, 事物的四大特性都是啥, 怎么实现的, 并发事物会带来什么问题, 怎么解决这些问题, 事务的隔离级别都有啥, 怎么实现这些隔离级别的, 看一个经典的转账场景啊, A给B转账100块钱, 你就得写两个SQL, B账户增加100块钱, A账户减少100块钱, 那给B账户加钱成功了, 但是A账户捡钱的时候发现余额不足失败了, 那B不就平白无故多加了100块钱吗, 在这个转账场景中, 这两个SQL应该是一个整体, 要么都成功, 要么都失败, 一个成功了, 一个失败了, 那数据就有问题了, 所以就需要有数据库事务, 所谓事物就是一系列SQL语句, 构成一个逻辑上的整体, 要么全部成功, 要么全部失败, 那给刚才的例子加上事务, 如果说B账户增加100块钱, 执行成功了, 那A账户减少100块钱, 执行失败了, 那就回滚对B账户的所有操作, 把这两个操作呢就变成了一个不可分割的整体, 要么全升功, 要么全失败, 不会说存在一个没有执行成功的一个中间串, 这就是事物的原则性, 那原则性怎么实现呢, 可以通过<strong>undo log回滚日志去实现</strong>啊, 比如说N个连续的四个操作失败了, 一个通过undo log给前面的操作全部回滚, 那失误提交之后, 如果数据库崩溃了, 那数据丢失了怎么办, 所以还要保持事物的一个持久性, 只要事务一提交, 无论发生什么事, 数据库的修改都不丢失, 那持久性怎么实现的呢, 通过redo log来实现, 每一次事务提交之后, 就把这个修改写入redo log, 那即便MYSQL数据没有持久化到磁盘中, 也能<strong>读取redo log来恢复数据, 所以redo log呢其实保证了事物的持久性</strong>, 这也就是为啥说redo log让MYSQL, 有了这个崩溃恢复的一个能力, 那就一定有人在想啊, 那redo log自己本身也要持久化到磁盘的, 他也是要刷盘的, 那就买SL崩了, 那redo log刷盘失败了, 那数据不就丢了, 这个问题呢后面讲到日志啊, 再详细去聊, 在并发执行事务的时候, 如果说事物A把商品库存从零修改为一事, 物B1读发现是一准备扣减库存啦, 但是失误A回滚了, 那又把商品库存回滚到零了, 那事务B在做扣减库存的操作不就会出问题吗, <strong>这是脏读啊</strong>, 一个事物读取到的, 另外一个事物没有提交的数据, 所以在并发执行事务的时候, 多个事物之间应该相互隔离, 互不影响, 否则就会出问题, 这就是事物的隔离性, 那隔离性怎么实现呢, 需要用MACC加锁去配置undo log去实现, 那这个就比较复杂了, 后面去详细聊啊, 除了这个原子性持久性隔离性之外, 事物还要保证一致性, 对于刚才的这个转账业务来说, 无论事物是否成功, 转账人和收款人的钱的总数应该是保持不变的, 如果说转账前后两个人一共100块钱, 转账之后两个人总额变300了, 那就那就有问题了, 那一致性怎么实现呢, 其实只要保证了原子性, 持久性, 隔离性, 一致性自然就实现了, 事物的并发执行会带来很多问题, 刚才讲隔离性提到了脏读一个事物, 读取到其他事物未提交的数据, 那么问题又来了, 然后事务B修改值为二, 事务B提交, 然后是为第二次读的时候, 发现值为二了, 那同一个事物中前后两次读取的数据不一致, 这就<strong>是不可重复读</strong>, 那么问题又又来啦, 查询id大于100的数据有十条, 然后事务B又差了20条数据, 发现A1大于100的有30条了, 这就是换读, <strong>幻读</strong>和不可重复读挺像的, 但是不可重复读呢强调的是多次读取, 那个数据值不一样, 换读呢强调的是数据条数的一个增减, 那怎么解决脏读不可重复读, 幻读的这些问题呢, 通过事务的隔离级别, 数据库呢提供了四种隔离级别呀, 读未提交, 读已提交, 可重复读, 串行化读未提交呢是最低的一种隔离级别, 每个事物都能看到其他事务未提交的一个数据, 读未提交呢它不能解决脏读啊, 不可重复读啊, 换读的问题啊, 所以实际根本就不会用独立提交, 那就是说每个事物只能读到其他事物, 已经提交的数据, 这就可以解决脏读的问题, 因为其他事物没提交的, 你读不到, 但是它无法解决不可重复读和幻读的问题, 可重复读呢是MYSQL的一个默认的隔离级别, 可重复读的这种隔离级别之下呢, 当你第一次去读的时候, 会生成一份数据快照, 生成快照之后, 其他事物的修改呢, 对当前事物来说就是不可见的, 因为你每次都读这个快照啊, 就能保证在同一个事物内, 两次读到的数据其实是一样的, 那就解决了不可重复读的问题, 你重复读他也不会读到这个值变了的那些数据, 但是他还是无法解决幻读的问题, 串行化呢是MYSQL最高的一个隔离级别, 串行化的要求事物你不能并发执行, 只能一个接一个的顺序执行, 你都无法并发执行了, 那那些并发问题自然就不存在了, 所以串行化呢是可以解决所有的并发问题, 但是性能很差, 并发量高的情况下, 可能就会导致大量的超时和所竞争的问题, 通常根本就不会用这个隔离级别, 所以呢可以看到啊, 就是事务的隔离级别越高, 就越能保证数据的一致性和完整性, 那执行效率也越低, 事务的隔离级别越低, 那执行的效率也就越高, 但是数据的一致性就越差, </p>
<p>那现在有这四种隔离级别能解决问题了, 那怎么实现这几种隔离级别呢, 首先读未提交应该怎么实现, 不用实现, 你根本就不用管, 因为<strong>多个并发事务同时执行</strong>, 天然就是<strong>读未提交</strong>, 所以呢根本就不用管, 根本就不用实现, 但是啊这里说的是读不用管, 那写的时候还是要加锁的, 你不能同时写一个数据, 那串行化应该怎么实现呢, 这就很简单了, 你直接加锁就行了, 只有拿到锁的事物才能执行, 这样事物就串行化执行了, 那读已提交和可重复读应该怎么实现呢, 这就涉及到了MYSQL中一个非常非常复杂, 而且很常考的东西啊, MVCC因为这个东西太复杂了, 所以这一期呢就长话短说, MVC的详细讲解放到下一期视频, MACC呢叫多版本并发控制, 就是维护数据的多个版本, 比如说某个数据第一个版本是一, 然后有事物修改为了二, 然后呢就产生了第二个版本, 又有事物修改成为三, 然后就产生了第三个版本, 那问题来了, 现在有个事物它需要读这个数据, 那他读到的是哪个版本, 版本一版本二还是版本三, 那他读到哪个版本, 取决于<strong>read view</strong>, 执行select的时候会生成一个快照啊, 叫read view, read view呢主要是用来判断数据版本, 对当前事物的可见性, 通过read view就能在一堆数据版本中找到哪个版本, 对当前事物是可见的, 你能读哪个版本, 然后呢把这个版本的数据给他返回, OK这就是MVCC的一个基本思想, 那讲完了MVCC, 那你来看一看可重复读和读, 已提交这两个隔离级别到底是怎么实现的, 可重复读呢怎么实现呢, 可重复读, 意思就是说每次会读到和第一次相同的数据, 即便后面有新事物修改的数据, 还是会读到和第一次相同的数据, 所以呢这就解决了不可重复读的问题, 那么问题来了, 怎么让每次让他都能读到相同的数据呢, 可重复读呢, 第一次select会生成一个review, 刚才说了, read view是判断数据版本对当前事物是否可见的, 所以呢可重复读每次都会<strong>复用第一次生成的review, 也就是说你生成这个review的时候, 哪些版本的数据对当前事物可见,</strong> 就已经固定下来了, 后续每次通过这个同一个review, 去判断数据的可见性, 那你能看到的数据版本都是一样的, 所以每一次读到的都是同一个数据版本, 那数据都是一样的, 无论其他事物再怎么改, 你看不到, OK这就解决了不可重复读的问题, 所以可重复读就是通过MACC加复, 用第一次的review去实现的, 除此之外呢可重复读呢, 他为了避免换毒问题, 还要加锁啊, 这个呢下期再聊吧, 这个就比较复杂了, 再看一下读已提交是怎么实现的, 毒已提交, 那就是说事物只能读取到其他事物, 已经提交的数据, 只要其他事物提交了, 你就能读到读已提交的本质, 那<strong>就是每次select就生成一个新的read view, 每次读都形成新的read view, 那每次就能读到最新的已经提交的数据版本</strong></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>信不信, 我花几分钟的时间就能让你彻底搞懂MACC, 要搞懂MAACC无非就是要搞懂下面几个问题, MAACC是什么, 用来解决什么问题的, MVACC怎么实现的, undo log版本链, read view是怎么回事, 四种隔离级别是怎么实现的, 什么是当前读, 什么是快照读, 可重复读的隔离级别, 怎么去避免患读问题, 但如果不能避免, 那举出反例, 那针对这种极端情况下的换图场景, 应该如何处理, 给一张数据库表里面存了很多数据, 现在有很多并发事物来访问或者修改数据, 上一期视频聊过了并发事物的情况下, 会出现脏读, 不可重复读幻读问题, 那你要解决脏读就得上毒已提交的隔离级别, 也就是说, 你得想办法保证一个事物只能读取到其他事物, 已经提交的数据, 其他事务没提交的, 你就不应该让它读到, 你要解决不可重复读的问题, 就得让可重复读的隔离级别, 也就是说一个事物第一次读取之后, 后面每次读取的数据都应该和第一次一样, 那怎么实现呢, 如果是你, 你要怎么设计呢, 你得维护一份数据的多个版本呀, 每个事物修改一次就得生成一个新的版本, 让不同的事物去读不同的版本, 在读已提交的这个隔离级别下啊, 让事物去读已经提交的数据版本, 这样就能避免脏读了, 那在不可重复读的隔离级别下, 让事物每次读到同一个版本的数据, 这样每次读到的都一样了, 就能避免可重复读的问题, 所以把修改的这个数据版本呀, 记录到一个undo log日志中, 然后呢给表增加一个隐藏字段, <strong>叫回滚指针</strong>, 那回滚指针呢指向这个undo log日志, 然后呢使用这个回回滚指针, 把这个历史版本串联成一个列表, 这样的话你想读哪个历史版本, 沿着列表一直找就可以了, 那么问题来了, 一个事物来查数据, 怎么知道我要查哪个版本的数据, 所以呢就得给每个事物分配个事务id, 事物id自增分配, 通过对比事物id的大小, 我就只能知道哪个事物创建的比较早, 哪个事物创建的比较晚, 然后再记录一下哪些事务提交了, 哪些事务没提交, 然后让提交的比较早的事物, 不要看到提交的比较晚的数据就可以了, 所以呢我们需要给表呢增加一个隐藏字段, 修改数据的事务id, 谁修改了, 它就把对应的事务id记录下来, 还需要一个东西啊, 叫review review呢, 有四个重要字段, creator transaction id就创建当前review的事务id, 还有一个MID意思就创建read view之前, 当前数据库活跃且未提交的所有事务id, mini transaction id创建read view时, 数据库活跃且未提交的最小输入id, 还有一个max transaction id, 就创建read view的时候, 应该分配给下一个新建事物的id, 那这些字段有啥用啊, 看图review的本质就是描绘了一个创建当前事务时, 各种事务id的一个数轴, 通过对比数据版本的transaction id, 在数轴的哪个位置, 就能知道这个数据版本, 对当前事物是否是可见的, 主要有这么几种情况, 如果说某一条数据的transaction id的这个值, 小于review里边的mi transaction id, 说明什么, 这个它比未提交的最小的事务id还小, 这就说明这个数据版本在创建这个review之前, 就生成了, 这个数据早就有了, 所以这个数据版本对当前的事物一定是可见的, 如果记录的这个transaction id值呢, 大于review的这个max traction id的这个值, 说明这个数据版本是在创建read view之后才启动的, 某个事物才生成的, 这新启动的事物创建的数据, 所以这个数据版本对当前事物一定是不可见的, 那如果说这个数据的traction id值呢, 在read view中的max传单x id和M传达x id之间, 那就得分情况了, 那如果这个数据版本的tracks id, 在m id这个列表中说明什么, 说明生成这个数据版本的这个事务还没提交, 他都没提交, 那可能肯定不能让当前事物看见啊, 所以是不可见的, 相反的, 如果说这个数据版本的transaction id啊, 不在MD这个列表中说明什么, 说明生成这个数据版本的事物已经提交了, 他已经提交了, 肯定就能看了, 所以这个数据版本对当前事物是可见的, 总结一下MACC每次修改数据, 就记录修改的这个事务id到这个隐藏字段, 然后呢生成一个版本, 去记录到这个redo log的版本量当中, 然后呢回滚指针指向版本链, 通过对比review和数据版本的这个事物id, 就能知道某个版本的数据, 对当前事物来说是否是可见的, 其实就是一句话, undo log去记录数据版本review, 去判断这个数据版本对当前事物的可见性, 这就是MACCMACC搞定了, 那怎么实现各个隔离级别呢, 首先读未提交, 怎么实现啊, 不用实现, 根本就不用你管多个并发事务同时执行, 它天然就是读未提交, 那串行化怎么实现加锁, 只有能拿到锁的事物才能执行, 这样事物就串行化执行了, 那么问题来了, 可重复读怎么实现, 怎么让它每次都读到相同的数据呢, 可重复读会在第一次select的时候生成一个review, 刚说了, Read view, 就是用来判断数据版本对当前事物的可见性的, 可乘无图, 每次都会复用第一次生成的review, 也就是说当生成这个read view的时候, 哪些版本的数据对当前数据可见, 已经固定下来了, 后续通过同一个review去判断数据的可见性, 所以每次读的都是同一批数据版本, 所以可重复读呢就是通过复用read view, 加上一个MVACC的机制来实现的, 除此之外可重复读呢为了避免幻读的问题, 还会加锁啊, 这个等会儿再聊, 再看读已提交怎么实现的, 读已提交的本质就是每次select的时候, 都会生成一个新的review, 每次读都形成了新的review, 那每次读都能读到新提交的这个数据版本了, 那么问题又又又来了, MYSQL的默认的隔离级别是可重复读, 可重复读能解决脏读和不可重复读, 但是换读的问题怎么解决, 串情话能解决换毒, 但是性能太差, 不推荐用, 所以只能考虑在可重复读的隔离级别下去解决, 换毒问题怎么办, 怎么解决, 这里分为两种情况啊, 第一种快照读, 在可重复读的隔离级别下, 当执行普通的select语句的时候, 通过MACC去读, 每次都读同一个数据版本, 这就是快照图, 普通select通过快照读去避免枷锁, 每次都读快照, 那别的师傅干了啥, 我读不到, 我只要读不到, 我就不会换读, 但你不能永远读不到吧, 比如说你开启了事务, 别人后开启的事物, 但是别人删插入了id为一的数据, 那你读不到, 然后你又以为id为一的数据不存在, 那你就插入id为一的数据, 能插吗, 肯定不能插呀, 所以插这种操作必须读到新的数据, 才能判断能不能让你插入, 这就是当前读执行select for update, 或者执行select in share mode, 或者说执行增删改的操作, 必须要读到最新的数据, 这就是当前读当前读读的都是最新的数据, 那如果其他事物插入了, 那不就还会产生幻读吗, 怎么办, 执行当前读MYSQL呢, 会使用零件锁去锁住数据和数据之间的间隙, 我加锁了, 你就不能插了, 只要我不让你插入, 不让你修改, 我就不会发生幻读, 举个例子啊, select字段from找表, where id大于100, For update, 查询id大于等于100的数据, 这里有发update, 所以是当前读会加锁, 那MYSQL呢就会锁住id等于100这条数据, 其他事物就不能再修改了, 然后呢再锁住100到正无穷这个区间, 他就不让你插入id大于100的数据了, 只要不让你插入, 我就不会换读, 所以在可重复读的隔离级别下, 通过MACC快照读, 再加上当前独家锁的方式去避免换读的, 那么问题又又又来了, 这样就真的能完全避免幻读吗, 真能吗, 很可惜并不能, MVCC加锁, 只能够避免大多数的换毒问题, 极端情况下还会出现幻读, 什么情况下会出现换堵呢, 先快照读, 在当前读的情况下就会出现换堵, 举个例子啊, 表里没有查不出来, 然后呢事务B再插入id等于一的数据, 再用普通的select查一等于一的数据还是查不出来, 因为是快照读, 但是示威使用select for update, 当前读去查就能查到id等于一的数据, 先快照读, 再当前读就出现了幻读, 再举一个更诡异的例子啊, 我们系统中按理来说用户名是不允许重复的, 所以给用户名呢加唯一索引, 然后呢一般先从数据库查哎, 这个用户名是否存在, 不存在才能让你添加这事物呢, 并发执行就是这样的, 用户名为AA的用户表里没有查不到, 然后呢, 事务B插入了用户名为AA的用户, 并提交事务, 事务A呢插入用户名等于AA插入不了, 提示用户名等于A已存在, 用户名等于AA的数据, 因为是快照组, 所以还是查不到, 发现问题了吗, 我查了, 明明没有用户名为AA这个数据, 但是一插入就显示已存在, 这就是换堵, 但是更骚的来了, 但是能直接update修改用户名为AA的数据, 就是这么诡异, 你查不到无法插入, 但是你可以改, 就这么诡异, 改完之后再去查就能查到了, 这又是一个先开照毒, 再当前毒产生的幻读, 那怎么办呢, 怎么去解决这种换毒问题, 其实就一点在一个事物操作某张表数据的时候, 另外一个事物不允许新增或者删除, 这张表的数据了, 在可重复读的隔离级别下, 要么就给表加表锁, 要么给数据加行锁, 怎么加呢, 可以使用select for update是吧, 那就是加表锁, 加了表锁之后, 事务B再插入数据就会阻塞我, 只要不让你插, 我就不会有幻读, 那如果说where条件中有索引列, 它就会加行锁, 比如说select字段from某张表, where r id大于五, and id小于十, 那这就会使用零件所锁住五和十这两条记录, 还会锁住五和十之间的间隙, 也就是说6789你也不能插, 我锁住了, 那其他的事物就不能让你插入, 那还是那个原则, 只要我不让你插, 我就不会换读</p>
<h2 id="mysql日志"><a href="#mysql日志" class="headerlink" title="mysql日志"></a>mysql日志</h2><p>信不信, 几分钟我就能让你整明白数据库三大日志, 要整明白数据库三大日志, 就是要整明白下面几个问题, 什么是undo log, undo log有什么用, 什么是redo log, redo log有什么用, 为什么要刷盘, redo log为什么不直接刷盘, 八分铺, 什么是blog, blog有什么用, 什么是两阶段提交, 怎么保证redo log和blog的一致性, MYSQL有事物, 事物的特性之一就是原子性, 执行一系列SQL要么全成功, 要么全失败, 后面的circle失败了, 那已经执行了也要回滚, 那么问题来了, 我数据都修改了, 怎么回滚到没有修改的版本呢, 这个时候就需要保存数据的不同版本了, 每修改一次, 就把原始的数据保本保存下来, 把数据的不同版本通过一个回滚指针串起来, 这个就叫undo log版本链, 也就是说事务执行的过程中修改了数据, MYSQL会把旧的数据记录到undo log日志里面, 如果事物正常提交, 那就结束, 如果说事物因为异常, 或者执行了手动回滚这种操作, 那就通过undo log去找到旧版本的数据回滚, 这也就是为什么说, <strong>undo log可以保证事物的原子性, 那undo log的第二个作用, 就是说配合read view和表的隐藏字段, 去实现MACC</strong>, 就是说MACC去执行普通select语句, 就会对比show id和review, 来查看这个数据版本对当前事物是否可见, 那不可见的话, 就沿着UNLOG的版本列, 继续查找当前事物可见的一个数据版本, 那这个呢在MACC那一期, 视频已经详细讲过了, 大家都知道MYSQL的数据是存在磁盘上的, 但是每次从磁盘中读数据, 写数据是不是太慢了, 怎么办呢, 那你想想写业务代码的时候查数据太慢了, 一般怎么办, 加一层缓存, 那你再想想CPU执行速度那么快, 内存的速度又那么慢, 那怎么办, CPU3级缓存, 所以遇事不决就加一层缓存, 那你猜猜MYSQL他自己怎么做的, 他也是这么想的, MYSQL呢设计了一个缓冲池, 叫八分P, MYSQL存数据是以页为单位的, 一个页16KB, 那每查询一条数据, 就会把硬盘这一页的数据加载出来, 把这个数据页呢放到八分库里面, 那么问题来了, 查一条数据, 把这一条数据放到缓存中不就行了, 那不至于把一个数据页全部都读取来, 放到这个Buff pool吧, 那这是啥操作呀, 我们幼儿园老师讲操作系统的时候应该教过啊, 程序有空间局部性原理, 也就是说一个内存位置被访问了, 这就意味着, 未来很有可能附近的内存位置都会被访问, 因为代码里会大量使用数组这种连续结构, 那数组第一个位置被访问了, 那第二个位置第三个位置大概率也还会被访问, 同样的一些管理系统里面, 分页展示了很多数据, 那你看完一页的数据, 还会接着点下一页, 下一页你刷抖音, 刷小红书一直往下滑, 这是连续翻页的过程, MYSQL一次把一个页的数据放入到八分布中, 那对于取连续数据来说, 命中率就很高了, 这就是利用了程序的一个空间, 局部性原理, 后续呢取数据先从八分库中取, 那没有再去磁盘里面读, 那写数据也是先写入八分库, 但是不会立刻刷盘, 而是把修改的这个页标记为脏页, 然后由后台线程在某个时间呢把脏页刷盘, 那问题来了, 八分后, 它是在内存中的, 他没有立即刷卡, 那MYSQL要是挂了, 那数据不就丢了, 所以就有了redo log, MYSQL每次把某个磁盘也做了什么样的修改, 记录到redo log中, 然后呢事务提交之后就刷盘, Redo log, 如果说八分库中的数据未刷盘就宕机了, 那么就可以读取redo log来恢复数据, 这也就是为什么说redo log, 能够保证事物的持久性, 让MYSQL能够做到崩溃恢复, 那为什么修改八块处之后, 他不直接刷盘呢, 而是去写RELOG去刷盘read log, 因为八分铺的刷盘是随机IO, 刷盘的时候需要找到某个磁盘页, 然后去修改, 然后再去找到另外一个磁盘页再修改, 那本来磁盘操作就慢, 你这随机IO的就不满了, 那redo log它只记录在哪个磁盘位置, 做了怎么样的修改, 那刷盘的时候, 只需要往RELOG日志文件后面追加就行了, 这就是顺序IO, 它不需要去找这个磁盘页, 哪个磁盘页, 它磁头往一个方向去移动就可以了, 这就是为什么, redo log里面要记录数据页的物理修改, 而不是直接去记录数据, 所以只要RELOG1刷盘, 即便MYSQL崩溃了也能恢复, 那事物的持久性也就得到保证了, 那么问题来了, redo log没刷盘, MYSQL就崩溃了, 怎么办, 解答这个问题之前, 就必须得先说一下, redo log其实也不是直接写入磁盘的, redo log也有自己的缓存呀, 叫redo log buffer, RELOG呢会写入read log buffer, 然后呢统一把RELOG8份中的数据刷盘到磁盘中, 那MYSQL中呢有一个参数叫ino dB, Flash log and transaction commit, 这个参数呢就是控制redo log一个刷盘时间的, 如果这个参数的值为零, 那事物提交的时候, 会把redo log的数据呢放到redo log8份, 但并不会刷盘, 所以这就比较危险, 那如果值为一, 那事务提交的时候就会把redo log数据刷入磁盘, 刷盘完成之后才告诉客户端事务执行成功了, 这就能够保证失误, 只要完成, 即便买错了, 崩溃了, 数据也不会丢失, 所以一般情况下把这个参数设置为一, 是比较稳妥的, 如果值为二, 那事务提交的时候, 就会把redo log的数据写入入, 操作系统的文件缓存里面, 就是写入配置cash, 操作系统本身对文件也是有缓存的, 这个缓存就是配置catch数据写入配置cat之后, 操作系统会在某一个时间, 真正的把这个数据写入磁盘中, 所以只要操作系统不崩溃, 那就能保证持久性, 但是如果说电脑突然断电了, 那数据还是会丢的, 听到这儿你就会发现哎, 原来计算机就是一个巨大的缓存, 处处都是缓存, 一层一层的缓存, 现在思考这样一个场景啊, 你要做数据库备份, 要做备份恢复, 那RELOG能用来做备份恢复吗, 或者说你要做主从主从复制能用redo log吗, 或者说你删除跑路了, 老板能用read log恢复数据吗, 不行为啥呢, 因为VLOG他不是一提交事务就会刷盘数据吗, 咋就不能做备份恢复或主从复制呢, 因为<strong>redo log它是循环写</strong>, 这日志空间的大小是固定的, 全部写满, 那就从头再开始写, 边写边擦除, 他就只能记录事务, 提交之后没有被刷盘那个数据, 那已经刷盘的会从RELOG中慢慢擦除掉的, 所以redo log它是事物级的数据记录, 它不是数据库级别的数据记录, 它只能做那些因为断电或者数据库故障, 导致八分库中数据为沙盘的这种数据恢复, 它不能做数据库全量的一个数据恢复, 那咋办呢, 要做备份恢复或者要做主从同步, 应该用啥呢, 只要对MYSQL做了变更, 无论是数据增删改还是表结构增删改, 都会记录一个日志, 叫blog redo log, 是循环写, <strong>blog是追加写</strong>, 它记录的是全量日志, 所以blog更适合用来做备份恢复或者主从模布, 那你删过之后, 最好把冰烙给删了再跑路, 这样你老板就很难恢复数据了, REVLOG呢是物理日志, 记录的是在某个数据页上做什么样的修改, 那blog呢是逻辑日志, 它记录的内容其实就类似于SQL语本身, 所以blog就非常适合去做这种备份恢复, 或者主从同步之前聊了这个八竿不缓存, 聊了redo log, redo log8分缓存, 那blog有没有类似的缓存机制, 哎有的有的缓存虽迟, 但到blog呢也有对应的这个blog catch啊, 事务执行的过程中, 会先把这个blog日志写到这个blog catch, 事务提交的时候, 就会把blog catch刷到磁盘中, 那么问题来了, 通过MYSQL的日志设计, 你学到了什么, 要保证持久化就得记日志, 对于连续写的日志, 最好搞一个catch, 先写catch, 然后异步刷盘, 通过日志就能做备份恢复, 主从同步哎, 说到这你想到了什么, 好像REDISRDB和AOF也是这个逻辑, 那么问题又又又来了, 事务提交之后, redo log和blog他都要刷盘, 那如果一个刷盘成功了, 另外一个失败了, 那两份日志就不一致了, 怎么办, 为了解决两份日志之间的一致性问题, MYSQL呢将redo log拆成了两个步骤, 去写<strong>prepare和commit,</strong> 这就是幼儿园老师常说这个两阶段提交, 那整个执行流程呢就分了这么几步啊, 第一步开始事务, 第二步更新数据, 第三步写入redo log, 此时的这个redo log是prepare阶段, 然后呢提交时, 然后写入blog, 把redo log设置为commit阶段, 如果写入read log异常了, 那也就是prepare异常了, 那read log和blog都没有, 那就直接回滚事务, 事务根本就没有提交成功, 那如果写入blog异常, 那MYSQL呢根据redo log进行日志恢复的时候, 就会发现redo log处于prepare阶段, 并且没有对应的blog日志, 那就回滚事务, 那如果说redo log设置commit是异常了, 那MYSQL就发现redo log是prepare阶段, 但是能找到对应的blog日志, 那blog和redo log就是一致的, 所以MYSQL也会认为数据是完整的, 所以直接提交事务, 所以两阶段提交最终还是要看blog, 只要blog刷盘了, 那就能提交事务</p>
<h2 id="redis应用"><a href="#redis应用" class="headerlink" title="redis应用"></a>redis应用</h2><p>你面试的时候有没有被问过REDIS的场景题, 比如说REDIS各种数据结构有什么作用啊, 都能干啥呀, 怎么用REDIS去实现一个IP限流啊, 怎么用REDIS去实现一个在线用户列表呀, 怎么实现一个实时的消息流啊, 怎么做抽奖呀, 怎么做点赞呀, 或者说你只会用REDIS做缓存项目, 也没有啥亮点, 那你可以好好看一下这期视频啊, 把REDIS各个功能都用到你的项目里面去, 先看一下REDIS的string结构啊, string就是一个单个的KV结构, 首先最常用的就是缓存对象, 这没啥好说的啊, 第二呢就是可以用sin x去实现一个分布式锁, 之前视频详细讲过了, 那第三呢可以实现一个共享session, 用户登录的时候生成一个token, 然后呢以token为key, 以用户信息为value, 给一个过期时间存到REDIS里面, 然后呢用户一段时间没访问系统就过期失效了, 需要重新登录了, 然后只要用户一访问, 那就通过拦截器给token续期, 这个就是共享session, 那第四呢three string呢这个原子性的一个自动操作, 可以去做一一个计数器啊, 去记录某个网页的访问量啊, 或者记录这个视频的播放次数, 那以网页路径或者视频id为这个key, 然后呢以次数为value, 访问一次就自增一次, 实现一个这么一个记录器的效果, 然后呢第五他可以做一个计数器限流, 比如说针对IP或者接口做一个限流, 以IP或者接口这个路径为key, 以访问次数为value, 访问一次自动一次, 当到了某个阈值的时候, 比如说每分之不能超过124就拒绝请求, 但是啊像这种计数器限流的一个问题, 就在于第一分钟和第2分钟那个交界处, 他会允许两倍的流量, 比如说第60秒来了120个请求, 第61秒又来了120个请求, 那这种情况下技术限流是拦不住的, 再看一下哈希结构, 希结构可以理解为, 是一个能够写多组KV的一个string, 首先呢哈希结构它可以存对象, 那如果说你要分开去存储对象, 不同字段的话, 要去精细修改某个对象的某个属性, 那用哈希是非常合适的, 那第二哈希结构呢还可以做购物车, 以用户id为key, 商品id为field的商品数据为value去搞一个购物车, 然后呢, 第三哈希结构还可以做一个动态的配置管理, 只能做一个简单的这种配置管理啊, 比如说做一些功能的开关之类的, 或者做一个动态的一个参数管理, 比如说以某个configure什么为key啊, 然后以功能为field, 以true或false为value, 那这样呢, 就相当于把REDIS, 当成了一个简单的配置中心去做了, 但REDIS它毕竟是基于内存的, 没那么可靠啊, 而且配置的发布变更其实也没有这个权限管控, 所以还是比较危险的, 最好还是用NUCKLES, 或者阿波罗这种专业的配置中心, 那如果说你的系统不想引入这么重的东西, 然后呢只想用ready is做一个简单的, 那也是完全OK的, 然后呢, 第四呢, 他可以去做一种多维度的一个数据统计啊, 比如说记录不同地区的一个视频的访问量, 以视频id为key, 以地区为field, 以访问次数为value, 访问一次就自增一次, 然后呢就实现了一个不同地区的一个视频, 访问量量的一个记录啊, 接下来就是redis list结构啊, list其实就是一个双端队列, 有序可重复, 然后呢既能够作为一个先进先出的队列去用, 又能够做一个后进先出的栈去用, 那首先呢, 这个list可以实现一个简单的消息队列啊, 消息的生产者呢直接l push push消息到这个list里面, 然后呢消息的消费者使用b r pop, 阻塞式的去读取这个数据, 那要保证消息不被重复处理, 保证消息的幂等性, 那你就给消息分配一个唯一id, 消息的消费者去保存这些处理过的消息id, 避免去做一个重复消费, 然后呢list去做一个简单的消息队列, 其实整体上是能用的, 但是你没有办法做消息的持久化, 没有办法去搞这个死信队列, 也没有办法去让多个消费者去消费同一条消息, 如果说系统比较小, 你不想引用那么重的MQ, 那你用redis list做一个消息队列, 其实是可以满足基本需求的, 但如果REDIS的版本比较高, 可以用stream stream是一个REDIS高版本, 专门用来做消息队列的那个工具, 功能功能更丰富一点, 更像一个完整的消息队列一点, 但是呢也是呃内存式的, 它没有做, 没有办法去做持久化, 所以还是和正式的消息队列相比, 还是有一点点缺陷, 但是呢啊整体已经好很多了, 如果说你不想引入一个重的MQ, OK你完全可以用stream或者用list去做, 然后第二呢类似的可以去做一个简单的一个, 实时的消息流啊, 比如说呃以用户的id为key, 消息id为value去存入这个list里面, 当某个人发帖子或者发朋友圈的时候, 就给放到用户的id对应的这个list里面, 当某个人去打开朋友圈, 然后呢就从list去读取一些数据, 然后呢显示到页面里, OK接下来呢就是REDIS的这个set结构, set其实就是一个无序无重复的一个集合, 那首先set特呢可以做一个抽奖系统, 直接把奖品艾特到这个set集合里面, 然后呢如果不允许重复中奖的那个场景, 那就直接s pop随意的移出一个元素, 那这个元素就是用户的奖品, 那如果说是允许重复中奖的场景, 那就直接s remember去随机获取一个元素, 这个就是用户的一个奖品, 因为set无序无重复的特性嘛, 所以其实可以做方便的去做一些数据, 去重的一些功能, 然后呢, 呃s is member, 这个查询命令的这个时间复杂度也是O1的, 所以你去做这种白名单啊, 判断一个数据是否在白名单里面, 也是非常不错的, 然后呢set还可以做这种点赞, 以帖子或者朋友圈id为key, 然后呢以点赞用户的id为value去存入set, 那谁点赞了就放入对应的set集合里面, 然后呢做点赞也是非常不错的, 然后SD还可以做交集并集差集等, 所以去比较适合去做那种共同好友啊, 共同兴趣啊等等, 共同好友就说以用户id为key, 以好友的id为value, 然后存入set, 然后呢去交集就能获取到这个共同好友, 但也可以去存这种用户的信息标签, 以用户id为key, 以兴趣标签为value存入set, 然后呢不同用户去交集, 他就能计算不同用户的这个功能兴趣, 最后呢就是z set, z set的特点就是有序无重复, 它每个元素都有一个score, 就用于排序, 那比较适合需要排序的那种场景, 那首先排序最常用的场景就是排行榜, 比如说积分排行榜或者说什么步数排行榜, 那以积分作为这个score, 然后用户id为value存入到一个z set里面, 然后使用使用那个z range, 就能从小到大去获取这个top n, 使用z r EV range, 就能获取到从大到小的一个top n, 然后呢z set也很适合做这种滑动窗口的限流啊, 比如说针对IP限流啊, 用户IP为key, 然后呢以请求的这个时间戳为score, 然后呢请求的id为value存入到z set, 那这样就能统计一分钟之内某个IP的请求次数, 然后超过阈值就进行限流, 所以set呢还能保存用户的这种浏览记录啊, 比如说以用户id为key, 以时间戳为score, 以这个帖子为member, 然后呢去放入到这个z set里面, 然后呢, 就可以按照时间范围快速的去做分页查询了, 那第四, 那c set还能实现这个在线的一个用户列表, 与用户活跃的时间戳为score, 然后用户id为value存入z set, 然后呢就可以去做这种按登录时间排序呀, 可以查询呀, 可以提前下线啊, 这种功能,</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">TTDB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/21/%E9%9D%A2%E8%AF%95/">http://example.com/2025/04/21/%E9%9D%A2%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">TTDB's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/0ed4d56b723a59b4303d73913cf16f7.jpg" target="_blank"><img class="post-qr-code-img" src="/img/0ed4d56b723a59b4303d73913cf16f7.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/8151e0eadcb22bce884312f7f78e0f6.jpg" target="_blank"><img class="post-qr-code-img" src="/img/8151e0eadcb22bce884312f7f78e0f6.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/21/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="刷题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">刷题</div></div><div class="info-2"><div class="info-item-1">零、常用枚举技巧枚举右，维护左对于 双变量问题，例如两数之和 a + b &#x3D; c ，可以枚举右边的 a,转化单变量问题 枚举中间对于三个或者四个变量的问题，枚举中间的变量往往更好算 2909. 元素和最小的山形三元组 II 给定(i，j，k)找出一个山形元素 1234567891011121314151617181920class Solution &#123;    public int minimumSum(int[] nums) &#123;        int n = nums.length;        int[] suf = new int[n]; // 后缀最小值        suf[n - 1] = nums[n - 1];        for (int i = n - 2; i &gt; 1; i--) &#123;            suf[i] = Math.min(suf[i + 1], nums[i]);        &#125;        int ans = Integer.MAX_VALUE;        int...</div></div></div></a><a class="pagination-related" href="/2025/04/21/%E5%AD%A6%E6%88%90-%E7%AC%94%E8%AE%B0/" title="学成tips"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">学成tips</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/12/redis%E9%9D%A2%E8%AF%95/" title="redis面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">redis面试</div></div><div class="info-2"><div class="info-item-1">为什么你的项目需要用到redis，高并发下有的项目也可以不用redis，mysql也行，淘宝是怎么做的redis最大的作用就是增加我的访问性能， 解决在海量数据下Mysql响应慢 项目中使用Redis，主要考虑性能和并发。其实不是所有的场景都要上Redis，如果仅仅是分布式锁这些，完全可以用中间件Zookpeer等代替。很多业务系统其实用数据库就够了，无脑上缓存&#x2F;NOSQL可能会带来更多更严重的问题。 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库 redis五种数据结构应用场景stringstring是一个K,V结构  通常用来缓存对象 stenx实现一个分布式锁 实现一个共享session，用户登录生成一个token，以用户信息为V,加上一个过期时间存放到redis中，访问刷新时间 计数器，记录网页的访问量或者是视频的播放次数，以网页路径或者视频id作为key，次数为value, 可以用来做一个限流，到达阈值就拒绝请求（ps：计数器限流的一个问题,...</div></div></div></a><a class="pagination-related" href="/2025/07/14/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/" title="简历"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-14</div><div class="info-item-2">简历</div></div><div class="info-2"><div class="info-item-1">第一版自我介绍我是XXX，本科毕业于XX大学，目前就读于XX大学，目前是是XX。主攻Java技术栈，专注后端开发方向，熟悉Spring Boot、MySQL、Redis等主流技术。 在项目方面，我主要有两个代表性实践：  慧通课程教育平台，采用Spring Cloud微服务架构，使用Mysql,mabaitsplus,redis，minio等中间件的使用 智能医疗大模型，主要是使用当下热门的langchain4j框架，开发，实现ai问答以及本地知识库问答  平常也会有将自己的技术学习发布自己博客的习惯。 很开兴能有这次面试机会。 Redis 相关问题Redis 是用来做什么的？redis主要用作高性能的缓存中间件  减轻数据库压力： 将频繁访问但改动不频繁的数据（如课程信息）存储在内存中，用户查询时直接读取 Redis，避免每次请求都访问较慢的 MySQL 数据库。 加速访问速度： 内存读写速度远快于磁盘（数据库），极大提升了数据获取速度，优化用户体验。 实现特定功能：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ab271877b6d5d966b6bcd9cda1623d51.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TTDB</div><div class="author-info-description">What can I do for you?</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/HgnGoning" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hgn314134@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">java特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.</span> <span class="toc-text">跨平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jvm"><span class="toc-number">1.2.1.</span> <span class="toc-text">Jvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E3%80%81JDK%E3%80%81JRE"><span class="toc-number">1.2.2.</span> <span class="toc-text">JVM、JDK、JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%92%8C%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">解释和编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">八种基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">转换问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigDecimal-%E5%92%8C-double"><span class="toc-number">1.5.</span> <span class="toc-text">bigDecimal 和 double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.6.</span> <span class="toc-text">装箱和拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E5%92%8Cint"><span class="toc-number">1.7.</span> <span class="toc-text">Integer和int</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">泛型中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">转换中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">集合中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3"><span class="toc-number">1.7.4.</span> <span class="toc-text">优劣</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.1.</span> <span class="toc-text">怎么理解面向对象？简单说说封装继承多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.2.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">多态解决了什么问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%97"><span class="toc-number">1.8.3.</span> <span class="toc-text">面向对象的设计原则你知道有哪些吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">重载与重写有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">抽象类和普通类区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">Java抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%8A%A0final%E4%BF%AE%E9%A5%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">抽象类不能加final修饰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.</span> <span class="toc-text">接口里面可以定义哪些方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97"><span class="toc-number">1.13.</span> <span class="toc-text">抽象类可以被实例化吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8AJava%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">解释Java中的静态变量和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">非静态内部类和静态内部类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84"><span class="toc-number">1.16.</span> <span class="toc-text">非静态内部类可以直接访问外部方法，编译器是怎么做到的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.16.1.</span> <span class="toc-text">编译器实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD-final-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.17.</span> <span class="toc-text">Java 中 final 作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.18.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.1.</span> <span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.19.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.19.1.</span> <span class="toc-text">为什么需要泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">1.20.1.</span> <span class="toc-text">java创建对象有哪些方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#New%E5%87%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6"><span class="toc-number">1.20.2.</span> <span class="toc-text">New出的对象什么时候回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.3.</span> <span class="toc-text">如何获取私有对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.21.</span> <span class="toc-text">反射*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">1.21.1.</span> <span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%86%99%E4%BB%A3%E7%A0%81%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.21.2.</span> <span class="toc-text">反射在你平时写代码或者框架中的应用场景有哪些</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.22.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.22.1.</span> <span class="toc-text">Java注解的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.22.2.</span> <span class="toc-text">注解解析的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.22.3.</span> <span class="toc-text">Java注解的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.23.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8"><span class="toc-number">1.23.1.</span> <span class="toc-text">Java异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.23.2.</span> <span class="toc-text">Java异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8throws%EF%BC%9F"><span class="toc-number">1.23.3.</span> <span class="toc-text">抛出异常为什么不用throws？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="toc-number">1.23.4.</span> <span class="toc-text">try catch中的语句运行情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-return-%E2%80%9Ca%E2%80%9D-fianlly-return-%E2%80%9Cb%E2%80%9D-%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E8%BF%94%E5%9B%9E%E5%95%A5"><span class="toc-number">1.23.5.</span> <span class="toc-text">try{return “a”} fianlly{return “b”}这条语句返回啥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">1.24.</span> <span class="toc-text">object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.24.1.</span> <span class="toc-text">&#x3D;&#x3D; 与 equals 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.24.2.</span> <span class="toc-text">hashcode和equals方法有什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.24.3.</span> <span class="toc-text">String、StringBuffer、StringBuilder的区别和联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.25.</span> <span class="toc-text">Java 8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.25.1.</span> <span class="toc-text">Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%ADstream%E7%9A%84API"><span class="toc-number">1.25.2.</span> <span class="toc-text">Java中stream的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E5%B9%B6%E8%A1%8CAPI-ParallelStream"><span class="toc-number">1.25.3.</span> <span class="toc-text">Stream流的并行API - ParallelStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completableFuture%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">1.25.4.</span> <span class="toc-text">completableFuture怎么用的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-21-%E6%96%B0%E7%89%B9%E6%80%A7%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.25.5.</span> <span class="toc-text">Java 21 新特性知道哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.26.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BB%8E%E4%B8%80%E4%B8%AAjvm%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAjvm"><span class="toc-number">1.26.1.</span> <span class="toc-text">怎么把一个对象从一个jvm转移到另一个jvm?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">1.26.2.</span> <span class="toc-text">序列化和反序列化让你自己实现你会怎么做?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.26.3.</span> <span class="toc-text">将对象转为二进制字节流具体怎么实现?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.27.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%92%8Csychronized%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.27.1.</span> <span class="toc-text">volatile和sychronized如何实现单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.27.2.</span> <span class="toc-text">代理模式和适配器模式有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-number">1.28.</span> <span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9CIO%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.28.1.</span> <span class="toc-text">Java怎么实现网络IO高并发编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E5%8C%BA%E5%88%AB"><span class="toc-number">1.28.2.</span> <span class="toc-text">BIO、NIO、AIO区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.28.3.</span> <span class="toc-text">NIO是怎么实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty"><span class="toc-number">1.28.3.1.</span> <span class="toc-text">Netty</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.29.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB%EF%BC%8C%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.29.1.</span> <span class="toc-text">有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="toc-number">1.29.2.</span> <span class="toc-text">Native方法解释一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81java%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">二、java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">数组与集合区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88-Collection"><span class="toc-number">2.2.</span> <span class="toc-text">Java中的集合-Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">Java中的线程安全的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%92%8CCollection"><span class="toc-number">2.4.</span> <span class="toc-text">Collections和Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">集合遍历的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.5.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%87%8C%E9%9D%A2list%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">2.5.1.</span> <span class="toc-text">java里面list的几种实现，几种实现有什么不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%BE%B9%E9%81%8D%E5%8E%86%E4%B8%80%E8%BE%B9%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.2.</span> <span class="toc-text">list可以一边遍历一边修改元素吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.3.</span> <span class="toc-text">list如何快速删除某个指定下标的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arraylist%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%93%AA%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">2.5.4.</span> <span class="toc-text">Arraylist和LinkedList的区别，哪个集合是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%8F%98%E6%88%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%EF%BC%9A"><span class="toc-number">2.5.5.</span> <span class="toc-text">ArrayList变成线程安全的方式有：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ArrayList%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%E6%98%AF%E5%93%AA%E9%87%8C%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">2.5.6.</span> <span class="toc-text">为什么ArrayList不是线程安全的，具体来说是哪里不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.7.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-List%EF%BC%8C-CopyonWriteArraylist%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">2.5.8.</span> <span class="toc-text">线程安全的 List， CopyonWriteArraylist是如何实现线程安全的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">2.6.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9map%E8%BF%9B%E8%A1%8C%E5%BF%AB%E9%80%9F%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">如何对map进行快速遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">HashMap实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">2.6.3.</span> <span class="toc-text">HashMap是线程安全的吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84put%E8%BF%87%E7%A8%8B"><span class="toc-number">2.6.4.</span> <span class="toc-text">hashmap的put过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">2.6.5.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#put-key-val-%E5%92%8Cget-key"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">put(key,val)和get(key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E9%80%82%E5%90%88%E5%81%9AKey"><span class="toc-number">2.6.5.2.</span> <span class="toc-text">String适合做Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.5.3.</span> <span class="toc-text">HashMap要用红黑树而不是平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap-key%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E5%90%97%EF%BC%9F"><span class="toc-number">2.6.5.4.</span> <span class="toc-text">hashmap key可以为null吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.5.5.</span> <span class="toc-text">多线程下可能会出现的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.5.6.</span> <span class="toc-text">扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.6.6.</span> <span class="toc-text">ConcurrentHashMap怎么实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E9%94%81%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">分段锁是可重入的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%B2%E7%BB%8F%E7%94%A8%E4%BA%86synchronized%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8CAS%E5%91%A2"><span class="toc-number">2.6.6.2.</span> <span class="toc-text">已经用了synchronized，为什么还要用CAS呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E7%94%A8%E4%BA%86%E6%82%B2%E8%A7%82%E9%94%81%E8%BF%98%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">2.6.6.3.</span> <span class="toc-text">ConcurrentHashMap用了悲观锁还是乐观锁?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.7.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0key%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">2.7.1.</span> <span class="toc-text">Set集合有什么特点？如何实现key无重复的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E7%9A%84Set%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AE%B0%E5%BD%95%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%9B%86%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">有序的Set是什么？记录插入顺序的集合是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81java%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">三、java并发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%93%E7%B3%BB%E5%8C%96%E5%85%AB%E8%82%A1"><span class="toc-number">4.</span> <span class="toc-text">四、体系化八股</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81MQ%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">如何保证MQ的可靠性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">4.2.1.</span> <span class="toc-text">Redis 分布式锁的原子性保障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%94%81%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E4%B8%8E%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 锁的自动释放与看门狗机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. 可重入锁的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E9%98%BB%E5%A1%9E%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">4. 可重入锁阻塞的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E9%94%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.</span> <span class="toc-text">5. 主从架构下的锁丢失问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-RedLock-%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.6.</span> <span class="toc-text">6. RedLock 算法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redisson-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.7.</span> <span class="toc-text">7. Redisson 的优化方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.2.8.</span> <span class="toc-text">8. 锁的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1"><span class="toc-number">4.2.9.</span> <span class="toc-text">9. 常见陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">4.3.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">synchronized的是什么能解决什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3synchronized%E6%80%8E%E4%B9%88%E7%94%A8%E5%91%A2"><span class="toc-number">4.3.2.</span> <span class="toc-text">那synchronized怎么用呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%9C%A8JDK1-6%E6%9C%89%E4%BC%98%E5%8C%96%E5%81%9A%E5%88%B0%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">4.3.3.</span> <span class="toc-text">synchronized的在JDK1.6有优化做到锁升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">4.4.</span> <span class="toc-text">CAS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">深入理解悲观锁与乐观锁：从概念到实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A%E8%B0%A8%E6%85%8E%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">一、悲观锁：谨慎的并发控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E7%9A%84%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">二、乐观锁：乐观的无锁并发思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89CAS%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">（一）CAS：乐观锁的经典实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81CAS-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E8%AF%81%EF%BC%9A%E4%BB%8E%E8%BD%AF%E4%BB%B6%E5%88%B0%E7%A1%AC%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">三、CAS 的原子性保证：从软件到硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Java-%E4%B8%AD%E7%9A%84-CAS-%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">（一）Java 中的 CAS 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BE%9D%E8%B5%96-CPU-%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.2.</span> <span class="toc-text">（二）依赖 CPU 原子指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81CAS-%E6%98%AF%E6%97%A0%E9%94%81%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%8D%E5%90%8C%E5%B1%82%E9%9D%A2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%AD%94%E6%A1%88"><span class="toc-number">5.4.</span> <span class="toc-text">四、CAS 是无锁的吗？不同层面的不同答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9F%BA%E4%BA%8E-CAS-%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9AAtomicInteger%E3%80%81AtomicLong%E3%80%81AtomicReference"><span class="toc-number">5.5.</span> <span class="toc-text">五、基于 CAS 的原子类：AtomicInteger、AtomicLong、AtomicReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E5%9F%BA%E4%BA%8E-CAS-%E6%80%9D%E6%83%B3"><span class="toc-number">5.6.</span> <span class="toc-text">六、数据库层面的乐观锁：基于 CAS 思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%93%E5%AD%98%E5%9C%BA%E6%99%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">（一）库存场景的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.2.</span> <span class="toc-text">（二）版本号机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81CAS-%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">5.7.</span> <span class="toc-text">七、CAS 的问题及解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89ABA-%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.1.</span> <span class="toc-text">（一）ABA 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E8%87%AA%E6%97%8B%E5%AF%BC%E8%87%B4-CPU-%E6%B5%AA%E8%B4%B9"><span class="toc-number">5.7.2.</span> <span class="toc-text">（二）自旋导致 CPU 浪费</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">5.9.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">AQS 基础概念详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81AQS-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">一、AQS 的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81AQS-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">二、AQS 的核心组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88state%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">（一）状态变量（state）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">（二）等待队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.</span> <span class="toc-text">三、AQS 的核心操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%EF%BC%88acquire%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">（一）获取资源（acquire）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90%EF%BC%88release%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">（二）释放资源（release）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AQS-%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">四、AQS 的模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81AQS-%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">五、AQS 的两种模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Threadlocal"><span class="toc-number">6.6.</span> <span class="toc-text">Threadlocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.7.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-number">6.8.</span> <span class="toc-text">JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.9.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.10.</span> <span class="toc-text">数据库事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">6.11.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E6%97%A5%E5%BF%97"><span class="toc-number">6.12.</span> <span class="toc-text">mysql日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%BA%94%E7%94%A8"><span class="toc-number">6.13.</span> <span class="toc-text">redis应用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/28/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="java设计模式">java设计模式</a><time datetime="2025-08-28T02:17:17.860Z" title="发表于 2025-08-28 10:17:17">2025-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="牛客面试题">牛客面试题</a><time datetime="2025-08-13T11:41:32.784Z" title="发表于 2025-08-13 19:41:32">2025-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/12/redis%E9%9D%A2%E8%AF%95/" title="redis面试">redis面试</a><time datetime="2025-08-12T02:06:27.028Z" title="发表于 2025-08-12 10:06:27">2025-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/06/java%E9%9B%86%E5%90%88/" title="java集合">java集合</a><time datetime="2025-08-06T03:16:04.399Z" title="发表于 2025-08-06 11:16:04">2025-08-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/14/git/" title="git使用">git使用</a><time datetime="2025-07-14T01:26:20.904Z" title="发表于 2025-07-14 09:26:20">2025-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By TTDB</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>